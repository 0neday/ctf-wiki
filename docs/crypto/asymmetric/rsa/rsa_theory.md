# RSA 介绍

RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。

RSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。

## 基本原理

### 公钥与私钥的产生

1. 随机选择两个不同大质数 $p$ 和 $q$，计算 $N = p \times q$
2. 根据欧拉函数，求得 $r=\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)$
3. 选择一个小于 $r$ 的整数 $e$，使 $e$ 和 $r$ 互质。并求得 $e$ 关于 $r$ 的模反元素，命名为 $d$，有 $ed\equiv 1 \pmod r$
4. 将 $p$ 和 $q$ 的记录销毁

此时，$(N,e)$ 是公钥，$(N,d)$ 是私钥。

### 消息加密

首先需要将消息 $m$ 以一个双方约定好的格式转化为一个小于 $N$，且与 $N$ 互质的整数 $n$。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：

$$
n^{e}\equiv c\pmod N
$$

### 消息解密

利用密钥 $d$ 进行解密。

$$
c^{d}\equiv n\pmod N
$$

### 正确性证明

即我们要证$n^{ed} \equiv n \bmod N$，已知$ed \equiv 1 \bmod \phi(N)$，那么 $ed=k\phi(N)+1$，即需要证明

$$
n^{k\phi(N)+1}  \equiv n \bmod N
$$

这里我们分两种情况证明

第一种情况 $gcd(n,N)=1$，那么 $n^{\phi(N)} \equiv 1 \bmod N$，因此原式成立。

第二种情况 $gcd(n,N)!=1$，那么 n 必然是 p 或者 q 的倍数，并且 n 小于 N。我们假设

$$
n=xp
$$

那么 x 必然小于 q，又由于 q 是素数。那么

$$
n^{\phi(q)} \equiv 1 \bmod q
$$

进而

$$
n^{k\phi(N)}=n^{k(p-1)(q-1)}=(n^{\phi(q)})^{k(p-1)} \equiv 1 \bmod q
$$

那么

$$
n^{k\phi(N)+1}=n+uqn
$$

进而

$$
n^{k\phi(N)+1}=n+uqxp=n+uxN
$$

所以原式成立。

## 基本工具

### RSAtool

-   安装

    ```bash
    git clone https://github.com/ius/rsatool.git
    cd rsatool
    python rsatool.py -h
    ```

-   生成私钥

    ```bash
    python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321
    ```

### RSA Converter

- 根据给定密钥对，生成 pem 文件
- 根据 n，e，d 得出 p，q

### openssl

-   查看公钥文件

    ```shell
    openssl rsa -pubin -in pubkey.pem -text -modulus
    ```

-   解密

    ```shell
    rsautl -decrypt -inkey private.pem -in flag.enc -out flag
    ```

更加具体的细节请参考 `openssl --help`。

### 分解整数工具

- 网站分解，[factor.db](http://factordb.com/)
- 命令行分解，[factordb-pycli](https://github.com/ryosan-470/factordb-pycli)，借用 factordb 数据库。
- [yafu](https://sourceforge.net/projects/yafu/)

### python 库

#### primefac

整数分解库，包含了很多整数分解的算法。

#### gmpy

- `gmpy.root(a, b)`，返回一个元组 `(x, y)`，其中 `x` 为 `a` 开 `b` 次方的值，`y` 是判断 `x` 是否为整数的布尔型变量

#### gmpy2

安装时，可能会需要自己另行安装 mfpr 与 mpc 库。

- `gmpy2.iroot(a, b)`，类似于 `gmpy.root(a,b)`

#### pycrypto

-   安装

    ```bash
    sudo pip install pycrypto
    ```

-   使用

    ```python
    import gmpy
    from Crypto.Util.number import *
    from Crypto.PublicKey import RSA
    from Crypto.Cipher import PKCS1_v1_5

    msg = 'crypto here'
    p = getPrime(128)
    q = getPrime(128)
    n = p*q
    e = getPrime(64)
    pubkey = RSA.construct((long(n), long(e)))
    privatekey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))
    key = PKCS1_v1_5.new(pubkey)
    enc = key.encrypt(msg).encode('base64')
    key = PKCS1_v1_5.new(privatekey)
    msg = key.decrypt(enc.decode('base64'), e)
    ```

## Jarvis OJ - Basic - veryeasyRSA

> p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389
>
> e = 65537
>
> 求 d = 
>
> 请提交 `PCTF{d}`

直接根据 $ed\equiv 1 \pmod r$，其中 $r=\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)$，可得 d。

```python
import gmpy2
p = 3487583947589437589237958723892346254777
q = 8767867843568934765983476584376578389
e = 65537
phin = (p - 1) * (q - 1)
print gmpy2.invert(e, phin)
```

```shell
➜  Jarvis OJ-Basic-veryeasyRSA git:(master) ✗ python exp.py       
19178568796155560423675975774142829153827883709027717723363077606260717434369
```

## 2018 CodeGate CTF Rsababy

程序就是一个简单的 RSA，不过程序还生成了两个奇怪的数

```python
e = 65537
n = p * q
pi_n = (p-1)*(q-1)
d = mulinv(e, pi_n)
h = (d+p)^(d-p)
g = d*(p-0xdeadbeef)
```

所以，问题应该出自这里，所以我们就从此下手，不放这里先假设 `const = 0xdeadbeef`。那么

$$
eg = ed*(p-const)
$$

进而，根据 RSA 可知

$$
2^{eg}=2^{ed*(p-const)}=2^{p-const} \pmod n
$$

$$
2^{p-const}*2^{const-1} = 2^{p-1} \pmod n
$$

所以

$$
2^{p-1} = 2^{eg}*2^{const-1}+kn
$$

而与此同时根据费马小定理，我们知道

$$
2^{p-1} \equiv 1 \pmod p
$$

所以

$$
p|2^{p-1}-1 | 2^{eg+const-1}-1+kn
$$

进而

$$
p|2^{eg+const-1}-1
$$

所以

$$
p|gcd(2^{eg+const-1}-1,n)
$$

因此，代码如下

```python
tmp = gmpy2.powmod(2,e*g+const-1,n)-1
p = gmpy2.gcd(tmp,n)
q = n/p
phin = (p-1)*(q-1)
d =gmpy2.invert(e,phin)
plain = gmpy2.powmod(data,d,n)
print hex(plain)[2:].decode('hex')
```

## 2018 国家安全周 pure math

题目的基本描述是这个样子的

```
1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492
2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323
3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406
4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279
5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030
Now, what’s the FLAG???
```

我们的目的基本上就是求得 Flag，那么怎么做呢?这个题目需要我们具有较好的数论功底。

根据题目中这样的内容，我们可以假设 p，q 都是大素数，那么

$p^{q-1} \equiv  1\bmod q$

那么

$p^{q} \equiv p \bmod pq$

那么我们可以根据 3 知道

$p^q+q^p \equiv p+q \bmod pq$

而 p+q 又显然小于 pq，所以我们就知道 p+q 的数值。

进一步，我们假设1，2，3，4，5对应的值分别为x1~x5则

根据4，我们可以知道

$(p+q)^{p+q} \equiv p^p+q^q \bmod pq$

又因为 1 和 2，则

$p^pp \equiv px_1\bmod pq$

$q^qq \equiv qx_2 \bmod pq$

因此

$px_1+qx_2 \equiv x_4 \bmod pq$

根据 x1 和 x2 的求得方式，我们可以知道这里也是等号，因此我们得到了一个二元一次方程组，直接求解即可。

```python
import gmpy2
x1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492
x2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323
p_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406
x4 = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279

if (x4 - x1 * p_q) % (x2 - x1) == 0:
    print 'True'
q = (x4 - x1 * p_q) / (x2 - x1)
print q
p = p_q - q

c = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030

phin = (p - 1) * (q - 1)
d = gmpy2.invert(31337, phin)
flag = gmpy2.powmod(c, d, p * q)
flag = hex(flag)[2:]
print flag.decode('hex')
```

flag  如下

```shell
➜  2018-国家安全周第一场-puremath git:(master) ✗ python exp.py
True
7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417
flag{6a66b8d5-6047-4299-a48e-4c4d1f874d12}
```

