


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>堆相关数据结构 &#8212; CTF Wiki </title>
    <link rel="stylesheet" href="../../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../_static/cloud.base.js"></script>
    <script type="text/javascript" src="../../_static/cloud.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="深入理解堆的实现" href="heap_implementation_details.html" />
    <link rel="prev" title="堆概述" href="heap_overview.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../index.html" title="內容目录"
             accesskey="C">toc</a></li>
        <li class="right" >
          <a href="heap_implementation_details.html" title="深入理解堆的实现"
             accesskey="N">下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="heap_overview.html" title="堆概述"
             accesskey="P">上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">CTF Wiki </a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">堆利用</a> &#187;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>堆相关数据结构<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>堆的操作就这么复杂，那么在 glibc 内部必然也有精心设计的数据结构来管理它。与堆相应的数据结构主要分为</p>
<ul class="simple">
<li>宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。</li>
<li>微观结构，用于具体处理堆的分配与回收中的内存块。</li>
</ul>
<div class="section" id="overview">
<h2>Overview？？？？<a class="headerlink" href="#overview" title="永久链接至标题">¶</a></h2>
<p><strong>这里给一个宏观的图片。</strong></p>
</div>
<div class="section" id="id2">
<h2>微观结构<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>这里首先介绍堆中比较细节的结构，<strong>堆的漏洞利用与这些结构密切相关</strong>。</p>
<div class="section" id="malloc-chunk">
<h3>malloc_chunk<a class="headerlink" href="#malloc-chunk" title="永久链接至标题">¶</a></h3>
<div class="section" id="id3">
<h4>概述<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p>
<p>非常有意思的是，<strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong>。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p>
<p>malloc_chunk 的结构如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
  <span class="n">This</span> <span class="n">struct</span> <span class="n">declaration</span> <span class="ow">is</span> <span class="n">misleading</span> <span class="p">(</span><span class="n">but</span> <span class="n">accurate</span> <span class="ow">and</span> <span class="n">necessary</span><span class="p">)</span><span class="o">.</span>
  <span class="n">It</span> <span class="n">declares</span> <span class="n">a</span> <span class="s2">&quot;view&quot;</span> <span class="n">into</span> <span class="n">memory</span> <span class="n">allowing</span> <span class="n">access</span> <span class="n">to</span> <span class="n">necessary</span>
  <span class="n">fields</span> <span class="n">at</span> <span class="n">known</span> <span class="n">offsets</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">given</span> <span class="n">base</span><span class="o">.</span> <span class="n">See</span> <span class="n">explanation</span> <span class="n">below</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>

  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">prev_size</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">Size</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">chunk</span> <span class="p">(</span><span class="k">if</span> <span class="n">free</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">size</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">including</span> <span class="n">overhead</span><span class="o">.</span> <span class="o">*/</span>

  <span class="n">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">double</span> <span class="n">links</span> <span class="o">--</span> <span class="n">used</span> <span class="n">only</span> <span class="k">if</span> <span class="n">free</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">Only</span> <span class="n">used</span> <span class="k">for</span> <span class="n">large</span> <span class="n">blocks</span><span class="p">:</span> <span class="n">pointer</span> <span class="n">to</span> <span class="nb">next</span> <span class="n">larger</span> <span class="n">size</span><span class="o">.</span>  <span class="o">*/</span>
  <span class="n">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="o">/*</span> <span class="n">double</span> <span class="n">links</span> <span class="o">--</span> <span class="n">used</span> <span class="n">only</span> <span class="k">if</span> <span class="n">free</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>首先，这里给出一些必要的解释 INTERNAL_SIZE_T，SIZE_SZ，MALLOC_ALIGN_MASK：</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of
   chunk sizes.
   The default version is the same as size_t.
   While not strictly necessary, it is best to define this as an
   unsigned type, even if size_t is a signed type. This may avoid some
   artificial size limitations on some systems.
   On a 64-bit machine, you may be able to reduce malloc overhead by
   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&#39; at the
   expense of not being able to handle more than 2^32 of malloced
   space. If this limitation is acceptable, you are encouraged to set
   this unless you are on a platform requiring 16byte alignments. In
   this case the alignment requirements turn out to negate any
   potential advantages of decreasing size_t word size.
   Implementors: Beware of the possible combinations of:
     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,
       and might be the same width as int or as long
     - size_t might have different width and signedness as INTERNAL_SIZE_T
     - int and long might be 32 or 64 bits, and might be the same width
   To deal with this, most comparisons and difference computations
   among INTERNAL_SIZE_Ts should cast them to unsigned long, being
   aware of the fact that casting an unsigned int to a wider long does
   not sign-extend. (This also makes checking for negative numbers
   awkward.) Some of these casts result in harmless compiler warnings
   on some systems.  */
#ifndef INTERNAL_SIZE_T
# define INTERNAL_SIZE_T size_t
#endif

/* The corresponding word size.  */
#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))

/* The corresponding bit mask value.  */
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)
</pre></div>
</div>
<p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p>
<p>每个字段的具体的解释如下</p>
<ul class="simple">
<li><strong>prev_size</strong>, 如果该 chunk 的<strong>物理相邻的前一地址chunk（两个指针的地址差值为前一chunk大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小(包括 chunk
头)。否则，该字段可以用来存储物理相邻的前一个chunk 的数据。<a href="#id4"><span class="problematic" id="id5">**</span></a>这里的前一 chunk 指的是较低地址的 chunk <a href="#id6"><span class="problematic" id="id7">**</span></a>。</li>
<li><strong>size</strong> ，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64
位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过
prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。</li>
</ul>
</li>
<li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p>一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为user data。每次 malloc 申请得到的内存指针，其实指向user data的起始处。</strong></p>
<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前chunk使用。<strong>这就是chunk中的空间复用。</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">chunk</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">chunk</span><span class="p">,</span> <span class="k">if</span> <span class="n">unallocated</span> <span class="p">(</span><span class="n">P</span> <span class="n">clear</span><span class="p">)</span>  <span class="o">|</span>
        <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">chunk</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">bytes</span>                     <span class="o">|</span><span class="n">A</span><span class="o">|</span><span class="n">M</span><span class="o">|</span><span class="n">P</span><span class="o">|</span>
  <span class="n">mem</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="n">User</span> <span class="n">data</span> <span class="n">starts</span> <span class="n">here</span><span class="o">...</span>                          <span class="o">.</span>
        <span class="o">.</span>                                                               <span class="o">.</span>
        <span class="o">.</span>             <span class="p">(</span><span class="n">malloc_usable_size</span><span class="p">()</span> <span class="nb">bytes</span><span class="p">)</span>                      <span class="o">.</span>
<span class="nb">next</span>    <span class="o">.</span>                                                               <span class="o">|</span>
<span class="n">chunk</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="p">(</span><span class="n">size</span> <span class="n">of</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">but</span> <span class="n">used</span> <span class="k">for</span> <span class="n">application</span> <span class="n">data</span><span class="p">)</span>    <span class="o">|</span>
        <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="nb">next</span> <span class="n">chunk</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">bytes</span>                <span class="o">|</span><span class="n">A</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">1</span><span class="o">|</span>
        <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></div>
</div>
<p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`head:&#39; |             Size of chunk, in bytes                     |A|0|P|
  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Forward pointer to next chunk in list             |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Back pointer to previous chunk in list            |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Unused space (may be 0 bytes long)                .
        .                                                               .
 next   .                                                               |
chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`foot:&#39; |             Size of chunk, in bytes                           |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|0|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ol class="arabic simple">
<li>本身的size字段会记录，</li>
<li>它后面的 chunk 会记录。</li>
</ol>
<p><strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<p><strong>！！！一些关于堆的约束，后面详细考虑！！！</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
    The three exceptions to all this are:
     1. The special chunk `top&#39; doesn&#39;t bother using the
    trailing size field since there is no next contiguous chunk
    that would have to index off it. After initialization, `top&#39;
    is forced to always exist.  If it would become less than
    MINSIZE bytes long, it is replenished.
     2. Chunks allocated via mmap, which have the second-lowest-order
    bit M (IS_MMAPPED) set in their size fields.  Because they are
    allocated one-by-one, each must contain its own trailing size
    field.  If the M bit is set, the other bits are ignored
    (because mmapped chunks are neither in an arena, nor adjacent
    to a freed chunk).  The M bit is also used for chunks which
    originally came from a dumped heap via malloc_set_state in
    hooks.c.
     3. Chunks in fastbins are treated as allocated chunks from the
    point of view of the chunk allocator.  They are consolidated
    with their neighbors only in bulk, in malloc_consolidate.
*/
</pre></div>
</div>
</div>
<div class="section" id="chunk">
<h4>chunk相关宏<a class="headerlink" href="#chunk" title="永久链接至标题">¶</a></h4>
<p>这里主要介绍 chunk 的大小、对齐检查以及一些转换的宏。</p>
<p><strong>chunk 与 mem 指针头部的转换</strong></p>
<p>mem指向用户得到的内存的起始位置。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">conversion</span> <span class="kn">from</span> <span class="nn">malloc</span> <span class="n">headers</span> <span class="n">to</span> <span class="n">user</span> <span class="n">pointers</span><span class="p">,</span> <span class="ow">and</span> <span class="n">back</span> <span class="o">*/</span>
<span class="c1">#define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span>
<span class="c1">#define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span>
</pre></div>
</div>
<p><strong>最小的 chunk 大小</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">The</span> <span class="n">smallest</span> <span class="n">possible</span> <span class="n">chunk</span> <span class="o">*/</span>
<span class="c1">#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span>
</pre></div>
</div>
<p>这里，offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。</p>
<p><strong>最小申请的堆内存大小</strong></p>
<p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p>
<p><strong>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的，个人认为之所以要添加两个宏是为了方便以后修改 malloc_chunk 时方便一些。</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">The</span> <span class="n">smallest</span> <span class="n">size</span> <span class="n">we</span> <span class="n">can</span> <span class="n">malloc</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">aligned</span> <span class="n">minimal</span> <span class="n">chunk</span> <span class="o">*/</span>
<span class="o">//</span><span class="n">MALLOC_ALIGN_MASK</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1">#define MINSIZE                                                                \</span>
    <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)</span> <span class="p">(((</span><span class="n">MIN_CHUNK_SIZE</span> <span class="o">+</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">)</span> <span class="o">&amp;</span>                   \
                      <span class="o">~</span><span class="n">MALLOC_ALIGN_MASK</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>检查分配给用户的内存是否对齐</strong></p>
<p>2 * SIZE_SZ 大小对齐。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Check if m has acceptable alignment */
// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1
#define aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p)                                                    \
    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \
     MALLOC_ALIGN_MASK)
</pre></div>
</div>
<p><strong>请求字节数判断</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Check</span> <span class="k">if</span> <span class="n">a</span> <span class="n">request</span> <span class="ow">is</span> <span class="n">so</span> <span class="n">large</span> <span class="n">that</span> <span class="n">it</span> <span class="n">would</span> <span class="n">wrap</span> <span class="n">around</span> <span class="n">zero</span> <span class="n">when</span>
   <span class="n">padded</span> <span class="ow">and</span> <span class="n">aligned</span><span class="o">.</span> <span class="n">To</span> <span class="n">simplify</span> <span class="n">some</span> <span class="n">other</span> <span class="n">code</span><span class="p">,</span> <span class="n">the</span> <span class="n">bound</span> <span class="ow">is</span> <span class="n">made</span>
   <span class="n">low</span> <span class="n">enough</span> <span class="n">so</span> <span class="n">that</span> <span class="n">adding</span> <span class="n">MINSIZE</span> <span class="n">will</span> <span class="n">also</span> <span class="ow">not</span> <span class="n">wrap</span> <span class="n">around</span> <span class="n">zero</span><span class="o">.</span>
 <span class="o">*/</span>

<span class="c1">#define REQUEST_OUT_OF_RANGE(req)                                              \</span>
    <span class="p">((</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">MINSIZE</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>将用户请求内存大小转为实际分配内存大小</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* pad request bytes into a usable size -- internal version */
//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1
#define request2size(req)                                                      \
    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \
         ? MINSIZE                                                             \
         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)

/*  Same, except also perform argument check */

#define checked_request2size(req, sz)                                          \
    if (REQUEST_OUT_OF_RANGE(req)) {                                           \
        __set_errno(ENOMEM);                                                   \
        return 0;                                                              \
    }                                                                          \
    (sz) = request2size(req);
</pre></div>
</div>
<p>当一个 chunk 处于已分配状态时，它的物理相邻的下一个 chunk 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 chunk 使用。这就是 ptmalloc 中 chunk 间的复用。具体流程如下</p>
<ol class="arabic simple">
<li>首先，利用 REQUEST_OUT_OF_RANGE 判断是否可以分配用户请求的字节大小的 chunk。</li>
<li>其次，需要注意的是用户请求的字节是用来存储数据的，即 chunk header 后面的部分。与此同时，由于chunk 间复用，所以可以使用下一个 chunk 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ
大小即可以完全存储内容。</li>
<li>由于系统中所允许的申请的 chunk 最小是 MINSIZE，所以与其进行比较。如果不满足最低要求，那么就需要直接分配MINSIZE字节。</li>
<li>如果大于的话，因为系统中申请的 chunk 需要 2 * SIZE_SZ 对齐，所以这里需要加上MALLOC_ALIGN_MASK 以便于对齐。</li>
</ol>
<p><strong>个人认为，这里在 request2size 的宏的第一行中没有必要加上 MALLOC_ALIGN_MASK。</strong></p>
<p><strong>需要注意的是，通过这样的计算公式得到的 size 最终一定是满足用户需要的。</strong></p>
<p><strong>标记位相关</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">size</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">or</span><span class="s1">&#39;ed with PREV_INUSE when previous adjacent chunk in use */</span>
<span class="c1">#define PREV_INUSE 0x1</span>

<span class="o">/*</span> <span class="n">extract</span> <span class="n">inuse</span> <span class="n">bit</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">chunk</span> <span class="o">*/</span>
<span class="c1">#define prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span>

<span class="o">/*</span> <span class="n">size</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">or</span><span class="s1">&#39;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span>
<span class="c1">#define IS_MMAPPED 0x2</span>

<span class="o">/*</span> <span class="n">check</span> <span class="k">for</span> <span class="n">mmap</span><span class="p">()</span><span class="s1">&#39;ed chunk */</span>
<span class="c1">#define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span>

<span class="o">/*</span> <span class="n">size</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">or</span><span class="s1">&#39;ed with NON_MAIN_ARENA if the chunk was obtained</span>
   <span class="kn">from</span> <span class="nn">a</span> <span class="n">non</span><span class="o">-</span><span class="n">main</span> <span class="n">arena</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">only</span> <span class="nb">set</span> <span class="n">immediately</span> <span class="n">before</span> <span class="n">handing</span>
   <span class="n">the</span> <span class="n">chunk</span> <span class="n">to</span> <span class="n">the</span> <span class="n">user</span><span class="p">,</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define NON_MAIN_ARENA 0x4</span>

<span class="o">/*</span> <span class="n">Check</span> <span class="k">for</span> <span class="n">chunk</span> <span class="kn">from</span> <span class="nn">main</span> <span class="n">arena</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span>

<span class="o">/*</span> <span class="n">Mark</span> <span class="n">a</span> <span class="n">chunk</span> <span class="k">as</span> <span class="ow">not</span> <span class="n">being</span> <span class="n">on</span> <span class="n">the</span> <span class="n">main</span> <span class="n">arena</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span>

<span class="o">/*</span>
   <span class="n">Bits</span> <span class="n">to</span> <span class="n">mask</span> <span class="n">off</span> <span class="n">when</span> <span class="n">extracting</span> <span class="n">size</span>
   <span class="n">Note</span><span class="p">:</span> <span class="n">IS_MMAPPED</span> <span class="ow">is</span> <span class="n">intentionally</span> <span class="ow">not</span> <span class="n">masked</span> <span class="n">off</span> <span class="kn">from</span> <span class="nn">size</span> <span class="n">field</span> <span class="ow">in</span>
   <span class="n">macros</span> <span class="k">for</span> <span class="n">which</span> <span class="n">mmapped</span> <span class="n">chunks</span> <span class="n">should</span> <span class="n">never</span> <span class="n">be</span> <span class="n">seen</span><span class="o">.</span> <span class="n">This</span> <span class="n">should</span>
   <span class="n">cause</span> <span class="n">helpful</span> <span class="n">core</span> <span class="n">dumps</span> <span class="n">to</span> <span class="n">occur</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">tried</span> <span class="n">by</span> <span class="n">accident</span> <span class="n">by</span>
   <span class="n">people</span> <span class="n">extending</span> <span class="ow">or</span> <span class="n">adapting</span> <span class="n">this</span> <span class="n">malloc</span><span class="o">.</span>
 <span class="o">*/</span>
<span class="c1">#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span>
</pre></div>
</div>
<p><strong>获取chunk size</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Get</span> <span class="n">size</span><span class="p">,</span> <span class="n">ignoring</span> <span class="n">use</span> <span class="n">bits</span> <span class="o">*/</span>
<span class="c1">#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span>

<span class="o">/*</span> <span class="n">Like</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">but</span> <span class="n">do</span> <span class="ow">not</span> <span class="n">mask</span> <span class="n">SIZE_BITS</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</span>
</pre></div>
</div>
<p><strong>获取下一个物理相邻的chunk</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Ptr</span> <span class="n">to</span> <span class="nb">next</span> <span class="n">physical</span> <span class="n">malloc_chunk</span><span class="o">.</span> <span class="o">*/</span>
<span class="c1">#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span>
</pre></div>
</div>
<p><strong>获取前一个chunk的信息</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">chunk</span> <span class="n">below</span> <span class="n">P</span><span class="o">.</span>  <span class="n">Only</span> <span class="n">valid</span> <span class="k">if</span> <span class="n">prev_inuse</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define prev_size(p) ((p)-&gt;mchunk_prev_size)</span>

<span class="o">/*</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">chunk</span> <span class="n">below</span> <span class="n">P</span><span class="o">.</span>  <span class="n">Only</span> <span class="n">valid</span> <span class="k">if</span> <span class="n">prev_inuse</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span>

<span class="o">/*</span> <span class="n">Ptr</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">physical</span> <span class="n">malloc_chunk</span><span class="o">.</span>  <span class="n">Only</span> <span class="n">valid</span> <span class="k">if</span> <span class="n">prev_inuse</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span>
</pre></div>
</div>
<p><strong>当前chunk使用状态相关操作</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">extract</span> <span class="n">p</span><span class="s1">&#39;s inuse bit */</span>
<span class="c1">#define inuse(p)                                                               \</span>
    <span class="p">((((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PREV_INUSE</span><span class="p">)</span>

<span class="o">/*</span> <span class="nb">set</span><span class="o">/</span><span class="n">clear</span> <span class="n">chunk</span> <span class="k">as</span> <span class="n">being</span> <span class="n">inuse</span> <span class="n">without</span> <span class="n">otherwise</span> <span class="n">disturbing</span> <span class="o">*/</span>
<span class="c1">#define set_inuse(p)                                                           \</span>
    <span class="p">((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">|=</span> <span class="n">PREV_INUSE</span>

<span class="c1">#define clear_inuse(p)                                                         \</span>
    <span class="p">((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PREV_INUSE</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>设置chunk的size字段</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Set</span> <span class="n">size</span> <span class="n">at</span> <span class="n">head</span><span class="p">,</span> <span class="n">without</span> <span class="n">disturbing</span> <span class="n">its</span> <span class="n">use</span> <span class="n">bit</span> <span class="o">*/</span>
<span class="o">//</span> <span class="n">SIZE_BITS</span> <span class="o">=</span> <span class="mi">7</span>
<span class="c1">#define set_head_size(p, s)                                                    \</span>
    <span class="p">((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">=</span> <span class="p">(((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">&amp;</span> <span class="n">SIZE_BITS</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span>

<span class="o">/*</span> <span class="n">Set</span> <span class="n">size</span><span class="o">/</span><span class="n">use</span> <span class="n">field</span> <span class="o">*/</span>
<span class="c1">#define set_head(p, s) ((p)-&gt;mchunk_size = (s))</span>

<span class="o">/*</span> <span class="n">Set</span> <span class="n">size</span> <span class="n">at</span> <span class="n">footer</span> <span class="p">(</span><span class="n">only</span> <span class="n">when</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">use</span><span class="p">)</span> <span class="o">*/</span>
<span class="c1">#define set_foot(p, s)                                                         \</span>
    <span class="p">(((</span><span class="n">mchunkptr</span><span class="p">)((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_prev_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>获取指定偏移的chunk</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Treat</span> <span class="n">space</span> <span class="n">at</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">as</span> <span class="n">a</span> <span class="n">chunk</span> <span class="o">*/</span>
<span class="c1">#define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span>
</pre></div>
</div>
<p><strong>指定偏移处chunk使用状态相关操作</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">check</span><span class="o">/</span><span class="nb">set</span><span class="o">/</span><span class="n">clear</span> <span class="n">inuse</span> <span class="n">bits</span> <span class="ow">in</span> <span class="n">known</span> <span class="n">places</span> <span class="o">*/</span>
<span class="c1">#define inuse_bit_at_offset(p, s)                                              \</span>
    <span class="p">(((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">&amp;</span> <span class="n">PREV_INUSE</span><span class="p">)</span>

<span class="c1">#define set_inuse_bit_at_offset(p, s)                                          \</span>
    <span class="p">(((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">|=</span> <span class="n">PREV_INUSE</span><span class="p">)</span>

<span class="c1">#define clear_inuse_bit_at_offset(p, s)                                        \</span>
    <span class="p">(((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PREV_INUSE</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bin">
<h3>bin<a class="headerlink" href="#bin" title="永久链接至标题">¶</a></h3>
<div class="section" id="id8">
<h4>概述<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>我们曾经说过，用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的chunk。当用户再一次请求分配内存时，ptmalloc
分配器会试图在空闲的chunk中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为4类：fast bins，small bins，large bins，unsorted
bin。每类中仍然有更细的划分，相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。</p>
<p>对于 small bins，large bins，unsorted bin 来说，Ptmalloc 将它们维护在同一个数组中。这些bin对应的数据结构在 malloc_state 中，如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="c1">#define NBINS 128</span>
<span class="o">/*</span> <span class="n">Normal</span> <span class="n">bins</span> <span class="n">packed</span> <span class="k">as</span> <span class="n">described</span> <span class="n">above</span> <span class="o">*/</span>
<span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span> <span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">];</span>
</pre></div>
</div>
<p>虽然每个 bin 的表头使用 mchunkptr 这个数据结构，但是这只是为了方便我们将每个 bin 转化为 malloc_chunk 指针。我们在使用时，会将这个指针当做一个 chunk 的 fd 或 bk
指针来操作，以便于将处于空闲的堆块链接在一起。这样可以节省空间，并提高可用性。那到底是怎么节省的呢？这里我们以32位系统为例</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="25%" />
<col width="20%" />
<col width="25%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">含义</th>
<th class="head">bin1的fd/bin2的prev_size</th>
<th class="head">bin1的bk/bin2的size</th>
<th class="head">bin2的fd/bin3的prev_size</th>
<th class="head">bin2的bk/bin3的size</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bin下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>可以看出除了第一个bin（unsorted bin）外，后面的每个bin会共享前面的bin的字段，将其视为malloc
chunk部分的prev_size和size。这里也说明了一个问题，<strong>bin的下标和我们所说的第几个bin并不是一致的。同时，bin表头的 chunk 的 prev_size 与 size 字段不能随便修改，因为这两个字段是被其它bin所利用的。</strong></p>
<p>数组中的 bin 依次介绍如下</p>
<ol class="arabic simple">
<li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为<strong>2个机器字长</strong>，即32位相差8字节，64位相差16字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的chunk 按 fd 指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些bin的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲chunk不能在一起</strong>。</p>
<p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk
的使用标记总是被置位的，所以不满足上面的原则。</strong></p>
<p>bin 通用的宏如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">malloc_chunk</span> <span class="o">*</span><span class="n">mbinptr</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">addressing</span> <span class="o">--</span> <span class="n">note</span> <span class="n">that</span> <span class="n">bin_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">exist</span> <span class="o">*/</span>
<span class="c1">#define bin_at(m, i)                                                           \</span>
    <span class="p">(</span><span class="n">mbinptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bins</span><span class="p">[</span> <span class="p">((</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">]))</span> <span class="o">-</span>                        \
              <span class="n">offsetof</span><span class="p">(</span><span class="n">struct</span> <span class="n">malloc_chunk</span><span class="p">,</span> <span class="n">fd</span><span class="p">))</span>

<span class="o">/*</span> <span class="n">analog</span> <span class="n">of</span> <span class="o">++</span><span class="nb">bin</span> <span class="o">*/</span>
<span class="o">//</span><span class="n">获取下一个bin的地址</span>
<span class="c1">#define next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span>

<span class="o">/*</span> <span class="n">Reminders</span> <span class="n">about</span> <span class="nb">list</span> <span class="n">directionality</span> <span class="n">within</span> <span class="n">bins</span> <span class="o">*/</span>
<span class="o">//</span> <span class="n">这两个宏可以用来遍历bin</span>
<span class="o">//</span> <span class="n">获取</span> <span class="nb">bin</span> <span class="n">的位于链表头的</span> <span class="n">chunk</span>
<span class="c1">#define first(b) ((b)-&gt;fd)</span>
<span class="o">//</span> <span class="n">获取</span> <span class="nb">bin</span> <span class="n">的位于链表尾的</span> <span class="n">chunk</span>
<span class="c1">#define last(b) ((b)-&gt;bk)</span>
</pre></div>
</div>
</div>
<div class="section" id="fast-bin">
<h4>fast bin<a class="headerlink" href="#fast-bin" title="永久链接至标题">¶</a></h4>
<p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk
进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中。</strong>因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Fastbins</span>

    <span class="n">An</span> <span class="n">array</span> <span class="n">of</span> <span class="n">lists</span> <span class="n">holding</span> <span class="n">recently</span> <span class="n">freed</span> <span class="n">small</span> <span class="n">chunks</span><span class="o">.</span>  <span class="n">Fastbins</span>
    <span class="n">are</span> <span class="ow">not</span> <span class="n">doubly</span> <span class="n">linked</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">faster</span> <span class="n">to</span> <span class="n">single</span><span class="o">-</span><span class="n">link</span> <span class="n">them</span><span class="p">,</span> <span class="ow">and</span>
    <span class="n">since</span> <span class="n">chunks</span> <span class="n">are</span> <span class="n">never</span> <span class="n">removed</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">middles</span> <span class="n">of</span> <span class="n">these</span> <span class="n">lists</span><span class="p">,</span>
    <span class="n">double</span> <span class="n">linking</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">necessary</span><span class="o">.</span> <span class="n">Also</span><span class="p">,</span> <span class="n">unlike</span> <span class="n">regular</span> <span class="n">bins</span><span class="p">,</span> <span class="n">they</span>
    <span class="n">are</span> <span class="ow">not</span> <span class="n">even</span> <span class="n">processed</span> <span class="ow">in</span> <span class="n">FIFO</span> <span class="n">order</span> <span class="p">(</span><span class="n">they</span> <span class="n">use</span> <span class="n">faster</span> <span class="n">LIFO</span><span class="p">)</span> <span class="n">since</span>
    <span class="n">ordering</span> <span class="n">doesn</span><span class="s1">&#39;t much matter in the transient contexts in which</span>
    <span class="n">fastbins</span> <span class="n">are</span> <span class="n">normally</span> <span class="n">used</span><span class="o">.</span>

    <span class="n">Chunks</span> <span class="ow">in</span> <span class="n">fastbins</span> <span class="n">keep</span> <span class="n">their</span> <span class="n">inuse</span> <span class="n">bit</span> <span class="nb">set</span><span class="p">,</span> <span class="n">so</span> <span class="n">they</span> <span class="n">cannot</span>
    <span class="n">be</span> <span class="n">consolidated</span> <span class="k">with</span> <span class="n">other</span> <span class="n">free</span> <span class="n">chunks</span><span class="o">.</span> <span class="n">malloc_consolidate</span>
    <span class="n">releases</span> <span class="nb">all</span> <span class="n">chunks</span> <span class="ow">in</span> <span class="n">fastbins</span> <span class="ow">and</span> <span class="n">consolidates</span> <span class="n">them</span> <span class="k">with</span>
    <span class="n">other</span> <span class="n">free</span> <span class="n">chunks</span><span class="o">.</span>
 <span class="o">*/</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">malloc_chunk</span> <span class="o">*</span><span class="n">mfastbinptr</span><span class="p">;</span>

<span class="o">/*</span>
    <span class="n">This</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">malloc_state</span><span class="o">.</span>
    <span class="o">/*</span> <span class="n">Fastbins</span> <span class="o">*/</span>
    <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span> <span class="n">NFASTBINS</span> <span class="p">];</span>
<span class="o">*/</span>
</pre></div>
</div>
<p>为了更加高效地利用 fast bin，glibc 采用单向链表对其中的每个 bin 进行组织，并且<strong>每个 bin 采取 LIFO 策略</strong>，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk
的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc才会做接下来的一系列操作。</p>
<p>默认情况下（<strong>32位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的chunk的数据空间最大为80字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10
个，从数据空间为8字节开始一直到80字节，定义如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>#define NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)

#ifndef DEFAULT_MXFAST
#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)
#endif

/* The maximum fastbin request size we support */
#define MAX_FAST_SIZE (80 * SIZE_SZ / 4)

/*
   Since the lowest 2 bits in max_fast don&#39;t matter in size comparisons,
   they are used as flags.
 */

/*
   FASTCHUNKS_BIT held in max_fast indicates that there are probably
   some fastbin chunks. It is set true on entering a chunk into any
   fastbin, and cleared only in malloc_consolidate.

   The truth value is inverted so that have_fastchunks will be true
   upon startup (since statics are zero-filled), simplifying
   initialization checks.
 */
//判断分配区是否有 fast bin chunk，1表示没有
#define FASTCHUNKS_BIT (1U)

#define have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)
#define clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)
#define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)

/*
   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous
   regions.  Otherwise, contiguity is exploited in merging together,
   when possible, results from consecutive MORECORE calls.

   The initial value comes from MORECORE_CONTIGUOUS, but is
   changed dynamically if mmap is ever used as an sbrk substitute.
 */
// MORECODE是否返回连续的内存区域。
// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间
// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为
// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。
#define NONCONTIGUOUS_BIT (2U)

#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)
#define noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)
#define set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)

/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the
   arena.  Such an arena is no longer used to allocate chunks.  Chunks
   allocated in that arena before detecting corruption are not freed.  */

#define ARENA_CORRUPTION_BIT (4U)

#define arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))
#define set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)

/*
   Set value of max_fast.
   Use impossibly small value if 0.
   Precondition: there are no existing fastbin chunks.
   Setting the value clears fastchunk bit but preserves noncontiguous bit.
 */

#define set_max_fast(s)                                                        \
    global_max_fast =                                                          \
        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))
#define get_max_fast() global_max_fast
</pre></div>
</div>
<p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p>
<p><strong>fastbin的索引</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])

/* offset 2 to use otherwise unindexable first 2 bins */
// chunk size=2*size_sz*(2+idx)
// 这里要减2，否则的话，前两个bin没有办法索引到。
#define fastbin_index(sz)                                                      \
    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)
</pre></div>
</div>
<p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的chunk合并。</strong></p>
<p>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于FASTBIN_CONSOLIDATION_THRESHOLD时，内存碎片可能比较多了，我们就需要把 fast bins 中的chunk都进行合并，以减少内存碎片对系统的影响。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">FASTBIN_CONSOLIDATION_THRESHOLD</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">a</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">free</span><span class="p">()</span>
   <span class="n">that</span> <span class="n">triggers</span> <span class="n">automatic</span> <span class="n">consolidation</span> <span class="n">of</span> <span class="n">possibly</span><span class="o">-</span><span class="n">surrounding</span>
   <span class="n">fastbin</span> <span class="n">chunks</span><span class="o">.</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">heuristic</span><span class="p">,</span> <span class="n">so</span> <span class="n">the</span> <span class="n">exact</span> <span class="n">value</span> <span class="n">should</span> <span class="ow">not</span>
   <span class="n">matter</span> <span class="n">too</span> <span class="n">much</span><span class="o">.</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">defined</span> <span class="n">at</span> <span class="n">half</span> <span class="n">the</span> <span class="n">default</span> <span class="n">trim</span> <span class="n">threshold</span> <span class="k">as</span> <span class="n">a</span>
   <span class="n">compromise</span> <span class="n">heuristic</span> <span class="n">to</span> <span class="n">only</span> <span class="n">attempt</span> <span class="n">consolidation</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">likely</span>
   <span class="n">to</span> <span class="n">lead</span> <span class="n">to</span> <span class="n">trimming</span><span class="o">.</span> <span class="n">However</span><span class="p">,</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dynamically</span> <span class="n">tunable</span><span class="p">,</span> <span class="n">since</span>
   <span class="n">consolidation</span> <span class="n">reduces</span> <span class="n">fragmentation</span> <span class="n">surrounding</span> <span class="n">large</span> <span class="n">chunks</span> <span class="n">even</span>
   <span class="k">if</span> <span class="n">trimming</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
 <span class="o">*/</span>

<span class="c1">#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span>
</pre></div>
</div>
<p><strong>malloc_consolidate函数可以将fastbin中所有的chunk释放并合并在一起。？？？</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
    <span class="n">Chunks</span> <span class="ow">in</span> <span class="n">fastbins</span> <span class="n">keep</span> <span class="n">their</span> <span class="n">inuse</span> <span class="n">bit</span> <span class="nb">set</span><span class="p">,</span> <span class="n">so</span> <span class="n">they</span> <span class="n">cannot</span>
    <span class="n">be</span> <span class="n">consolidated</span> <span class="k">with</span> <span class="n">other</span> <span class="n">free</span> <span class="n">chunks</span><span class="o">.</span> <span class="n">malloc_consolidate</span>
    <span class="n">releases</span> <span class="nb">all</span> <span class="n">chunks</span> <span class="ow">in</span> <span class="n">fastbins</span> <span class="ow">and</span> <span class="n">consolidates</span> <span class="n">them</span> <span class="k">with</span>
    <span class="n">other</span> <span class="n">free</span> <span class="n">chunks</span><span class="o">.</span>
 <span class="o">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="small-bin">
<h4>small bin<a class="headerlink" href="#small-bin" title="永久链接至标题">¶</a></h4>
<p>small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size =2 * SIZE_SZ *index，具体如下</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="43%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">下标</th>
<th class="head">SIZE_SZ=4（32位）</th>
<th class="head">SIZE_SZ=8（64位）</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr class="row-even"><td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>40</td>
<td>80</td>
</tr>
<tr class="row-even"><td>x</td>
<td>2*4*x</td>
<td>2*8*x</td>
</tr>
<tr class="row-odd"><td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody>
</table>
<p>small bins 中一共有 62 个链表，每个链表中存储的 chunk 大小都一致。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 chunk 大小为均为 16
字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</p>
<p>small bin相关的宏如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>#define NSMALLBINS 64
#define SMALLBIN_WIDTH MALLOC_ALIGNMENT
// 是否需要对small bin的下标进行纠正
#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)

#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)
//判断chunk的大小是否在small bin范围内
#define in_smallbin_range(sz)                                                  \
    ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)
// 根据chunk的大小得到small bin对应的索引。
#define smallbin_index(sz)                                                     \
    ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4)                          \
                           : (((unsigned) (sz)) &gt;&gt; 3)) +                       \
     SMALLBIN_CORRECTION)
</pre></div>
</div>
<p><strong>或许，大家会很疑惑，那 fastbin 与 small bin 中 chunk 的大小会有很大一部分重合啊，那 small bin 中对应大小的 bin 是不是就没有什么作用啊？</strong> 其实不然，fast bin 中的 chunk 是有可能被放到small
bin中去的。</p>
</div>
<div class="section" id="large-bin">
<h4>large bin<a class="headerlink" href="#large-bin" title="永久链接至标题">¶</a></h4>
<p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="32%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">组</th>
<th class="head">数量</th>
<th class="head">公差</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr class="row-even"><td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr class="row-even"><td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody>
</table>
<p>这里我们以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该bin 可以存储的 chunk 的大小范围为 [512,512+64)。</p>
<p>关于 large bin 的宏如下，这里我们以 32 位平台下，第一个 large bin 的起始 chunk 大小为例，为 512 字节，那么 512&gt;&gt;6 = 8，所以其下标为56+8=64。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>#define largebin_index_32(sz)                                                  \
    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38)                                     \
         ? 56 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \
         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \
               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \
               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \
                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \
                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \
                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \
                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \
                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \
                                 : 126)

#define largebin_index_32_big(sz)                                              \
    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45)                                     \
         ? 49 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \
         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \
               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \
               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \
                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \
                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \
                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \
                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \
                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \
                                 : 126)

// XXX It remains to be seen whether it is good to keep the widths of
// XXX the buckets the same or whether it should be scaled by a factor
// XXX of two as well.
#define largebin_index_64(sz)                                                  \
    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48)                                     \
         ? 48 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \
         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \
               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \
               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \
                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \
                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \
                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \
                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \
                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \
                                 : 126)

#define largebin_index(sz)                                                     \
    (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16             \
                                                ? largebin_index_32_big(sz)    \
                                                : largebin_index_32(sz))
</pre></div>
</div>
</div>
<div class="section" id="unsorted-bin">
<h4>unsorted bin<a class="headerlink" href="#unsorted-bin" title="永久链接至标题">¶</a></h4>
<p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>其在 glibc 中具体的说明如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Unsorted</span> <span class="n">chunks</span>

    <span class="n">All</span> <span class="n">remainders</span> <span class="kn">from</span> <span class="nn">chunk</span> <span class="n">splits</span><span class="p">,</span> <span class="k">as</span> <span class="n">well</span> <span class="k">as</span> <span class="nb">all</span> <span class="n">returned</span> <span class="n">chunks</span><span class="p">,</span>
    <span class="n">are</span> <span class="n">first</span> <span class="n">placed</span> <span class="ow">in</span> <span class="n">the</span> <span class="s2">&quot;unsorted&quot;</span> <span class="nb">bin</span><span class="o">.</span> <span class="n">They</span> <span class="n">are</span> <span class="n">then</span> <span class="n">placed</span>
    <span class="ow">in</span> <span class="n">regular</span> <span class="n">bins</span> <span class="n">after</span> <span class="n">malloc</span> <span class="n">gives</span> <span class="n">them</span> <span class="n">ONE</span> <span class="n">chance</span> <span class="n">to</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span>
    <span class="n">binning</span><span class="o">.</span> <span class="n">So</span><span class="p">,</span> <span class="n">basically</span><span class="p">,</span> <span class="n">the</span> <span class="n">unsorted_chunks</span> <span class="nb">list</span> <span class="n">acts</span> <span class="k">as</span> <span class="n">a</span> <span class="n">queue</span><span class="p">,</span>
    <span class="k">with</span> <span class="n">chunks</span> <span class="n">being</span> <span class="n">placed</span> <span class="n">on</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">free</span> <span class="p">(</span><span class="ow">and</span> <span class="n">malloc_consolidate</span><span class="p">),</span>
    <span class="ow">and</span> <span class="n">taken</span> <span class="n">off</span> <span class="p">(</span><span class="n">to</span> <span class="n">be</span> <span class="n">either</span> <span class="n">used</span> <span class="ow">or</span> <span class="n">placed</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">)</span> <span class="ow">in</span> <span class="n">malloc</span><span class="o">.</span>

    <span class="n">The</span> <span class="n">NON_MAIN_ARENA</span> <span class="n">flag</span> <span class="ow">is</span> <span class="n">never</span> <span class="nb">set</span> <span class="k">for</span> <span class="n">unsorted</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">so</span> <span class="n">it</span>
    <span class="n">does</span> <span class="ow">not</span> <span class="n">have</span> <span class="n">to</span> <span class="n">be</span> <span class="n">taken</span> <span class="n">into</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">size</span> <span class="n">comparisons</span><span class="o">.</span>
 <span class="o">*/</span>
</pre></div>
</div>
<p>从下面的宏我们可以看出</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">The</span> <span class="n">otherwise</span> <span class="n">unindexable</span> <span class="mi">1</span><span class="o">-</span><span class="nb">bin</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">unsorted</span> <span class="n">chunks</span><span class="o">.</span> <span class="o">*/</span>
<span class="c1">#define unsorted_chunks(M) (bin_at(M, 1))</span>
</pre></div>
</div>
<p>unsorted bin 处于我们之前所说的bin数组下标1处。故而 unsorted bin只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p>
<ul class="simple">
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。</li>
</ul>
<p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>
</div>
<div class="section" id="common-macro">
<h4>common macro<a class="headerlink" href="#common-macro" title="永久链接至标题">¶</a></h4>
<p>这里介绍一些通用的宏。</p>
<p><strong>根据chunk的大小统一地获得chunk所在的索引</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>#define bin_index(sz)                                                          \
    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))
</pre></div>
</div>
</div>
</div>
<div class="section" id="top-chunk">
<h3>top chunk<a class="headerlink" href="#top-chunk" title="永久链接至标题">¶</a></h3>
<p>glibc 中对于 top chunk 的描述如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Top</span>

    <span class="n">The</span> <span class="n">top</span><span class="o">-</span><span class="n">most</span> <span class="n">available</span> <span class="n">chunk</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="n">the</span> <span class="n">one</span> <span class="n">bordering</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span>
    <span class="n">available</span> <span class="n">memory</span><span class="p">)</span> <span class="ow">is</span> <span class="n">treated</span> <span class="n">specially</span><span class="o">.</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">never</span> <span class="n">included</span> <span class="ow">in</span>
    <span class="nb">any</span> <span class="nb">bin</span><span class="p">,</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">only</span> <span class="k">if</span> <span class="n">no</span> <span class="n">other</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="n">available</span><span class="p">,</span> <span class="ow">and</span> <span class="ow">is</span>
    <span class="n">released</span> <span class="n">back</span> <span class="n">to</span> <span class="n">the</span> <span class="n">system</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">very</span> <span class="n">large</span> <span class="p">(</span><span class="n">see</span>
    <span class="n">M_TRIM_THRESHOLD</span><span class="p">)</span><span class="o">.</span>  <span class="n">Because</span> <span class="n">top</span> <span class="n">initially</span>
    <span class="n">points</span> <span class="n">to</span> <span class="n">its</span> <span class="n">own</span> <span class="nb">bin</span> <span class="k">with</span> <span class="n">initial</span> <span class="n">zero</span> <span class="n">size</span><span class="p">,</span> <span class="n">thus</span> <span class="n">forcing</span>
    <span class="n">extension</span> <span class="n">on</span> <span class="n">the</span> <span class="n">first</span> <span class="n">malloc</span> <span class="n">request</span><span class="p">,</span> <span class="n">we</span> <span class="n">avoid</span> <span class="n">having</span> <span class="nb">any</span> <span class="n">special</span>
    <span class="n">code</span> <span class="ow">in</span> <span class="n">malloc</span> <span class="n">to</span> <span class="n">check</span> <span class="n">whether</span> <span class="n">it</span> <span class="n">even</span> <span class="n">exists</span> <span class="n">yet</span><span class="o">.</span> <span class="n">But</span> <span class="n">we</span> <span class="n">still</span>
    <span class="n">need</span> <span class="n">to</span> <span class="n">do</span> <span class="n">so</span> <span class="n">when</span> <span class="n">getting</span> <span class="n">memory</span> <span class="kn">from</span> <span class="nn">system</span><span class="p">,</span> <span class="n">so</span> <span class="n">we</span> <span class="n">make</span>
    <span class="n">initial_top</span> <span class="n">treat</span> <span class="n">the</span> <span class="nb">bin</span> <span class="k">as</span> <span class="n">a</span> <span class="n">legal</span> <span class="n">but</span> <span class="n">unusable</span> <span class="n">chunk</span> <span class="n">during</span> <span class="n">the</span>
    <span class="n">interval</span> <span class="n">between</span> <span class="n">initialization</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">first</span> <span class="n">call</span> <span class="n">to</span>
    <span class="n">sysmalloc</span><span class="o">.</span> <span class="p">(</span><span class="n">This</span> <span class="ow">is</span> <span class="n">somewhat</span> <span class="n">delicate</span><span class="p">,</span> <span class="n">since</span> <span class="n">it</span> <span class="n">relies</span> <span class="n">on</span>
    <span class="n">the</span> <span class="mi">2</span> <span class="n">preceding</span> <span class="n">words</span> <span class="n">to</span> <span class="n">be</span> <span class="n">zero</span> <span class="n">during</span> <span class="n">this</span> <span class="n">interval</span> <span class="k">as</span> <span class="n">well</span><span class="o">.</span><span class="p">)</span>
 <span class="o">*/</span>

<span class="o">/*</span> <span class="n">Conveniently</span><span class="p">,</span> <span class="n">the</span> <span class="n">unsorted</span> <span class="nb">bin</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="k">as</span> <span class="n">dummy</span> <span class="n">top</span> <span class="n">on</span> <span class="n">first</span> <span class="n">call</span> <span class="o">*/</span>
<span class="c1">#define initial_top(M) (unsorted_chunks(M))</span>
</pre></div>
</div>
<p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个
bin，它的作用在于当所有的bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对heap进行扩展后再进行分配。在main
arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为1，否则其前面的chunk就会被合并到top chunk中。</p>
<p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p>
</div>
<div class="section" id="last-remainder">
<h3>last remainder<a class="headerlink" href="#last-remainder" title="永久链接至标题">¶</a></h3>
<p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不是和申请的大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin也会存这一块。top chunk
分割剩下的部分不会作为last remainer.</p>
</div>
</div>
<div class="section" id="id9">
<h2>宏观结构<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<div class="section" id="arena">
<h3>arena<a class="headerlink" href="#arena" title="永久链接至标题">¶</a></h3>
<p>在我们之前介绍的例子中，无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的arena。那么会不会每个线程都有独立的arena呢？下面我们就具体介绍。</p>
<div class="section" id="id10">
<h4>arena 数量<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<p>对于不同系统，arena数量的<a class="reference external" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847">约束</a>如下</p>
<div class="code text highlight-default"><div class="highlight"><pre><span></span><span class="n">For</span> <span class="mi">32</span> <span class="n">bit</span> <span class="n">systems</span><span class="p">:</span>
     <span class="n">Number</span> <span class="n">of</span> <span class="n">arena</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">cores</span><span class="o">.</span>
<span class="n">For</span> <span class="mi">64</span> <span class="n">bit</span> <span class="n">systems</span><span class="p">:</span>
     <span class="n">Number</span> <span class="n">of</span> <span class="n">arena</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">cores</span><span class="o">.</span>
</pre></div>
</div>
<p>显然，不是每一个线程都会有对应的
arena。至于为什么64位系统，要那么设置，我也没有想明白。此外，因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 arena。</p>
</div>
<div class="section" id="id11">
<h4>arena 分配规则<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p><strong>待补充。</strong></p>
</div>
<div class="section" id="id12">
<h4>区别<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<p>与 thread 不同的是，main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p>
</div>
</div>
<div class="section" id="heap-info">
<h3>heap_info<a class="headerlink" href="#heap-info" title="永久链接至标题">¶</a></h3>
<p>程序刚开始执行时，每个线程是没有 heap 区域的。当其申请内存时，就需要一个结构来记录对应的信息，而heap_info 的作用就是这个。而且当该heap的资源被使用完后，就必须得再次申请内存了。此外，一般申请的heap
是不连续的，因此需要记录不同heap之间的链接结构。</p>
<p><strong>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程准备的。</strong></p>
<p>主线程可以通过 sbrk() 函数扩展 program break location 获得（直到触及Memory Mapping Segment），只有一个heap，没有 heap_info 数据结构。</p>
<p>heap_info 的主要结构如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="c1">#define HEAP_MIN_SIZE (32 * 1024)</span>
<span class="c1">#ifndef HEAP_MAX_SIZE</span>
<span class="c1"># ifdef DEFAULT_MMAP_THRESHOLD_MAX</span>
<span class="c1">#  define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span>
<span class="c1"># else</span>
<span class="c1">#  define HEAP_MAX_SIZE (1024 * 1024) /* must be a power of two */</span>
<span class="c1"># endif</span>
<span class="c1">#endif</span>

<span class="o">/*</span> <span class="n">HEAP_MIN_SIZE</span> <span class="ow">and</span> <span class="n">HEAP_MAX_SIZE</span> <span class="n">limit</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">mmap</span><span class="p">()</span><span class="n">ed</span> <span class="n">heaps</span>
   <span class="n">that</span> <span class="n">are</span> <span class="n">dynamically</span> <span class="n">created</span> <span class="k">for</span> <span class="n">multi</span><span class="o">-</span><span class="n">threaded</span> <span class="n">programs</span><span class="o">.</span>  <span class="n">The</span>
   <span class="n">maximum</span> <span class="n">size</span> <span class="n">must</span> <span class="n">be</span> <span class="n">a</span> <span class="n">power</span> <span class="n">of</span> <span class="n">two</span><span class="p">,</span> <span class="k">for</span> <span class="n">fast</span> <span class="n">determination</span> <span class="n">of</span>
   <span class="n">which</span> <span class="n">heap</span> <span class="n">belongs</span> <span class="n">to</span> <span class="n">a</span> <span class="n">chunk</span><span class="o">.</span>  <span class="n">It</span> <span class="n">should</span> <span class="n">be</span> <span class="n">much</span> <span class="n">larger</span> <span class="n">than</span> <span class="n">the</span>
   <span class="n">mmap</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">so</span> <span class="n">that</span> <span class="n">requests</span> <span class="k">with</span> <span class="n">a</span> <span class="n">size</span> <span class="n">just</span> <span class="n">below</span> <span class="n">that</span>
   <span class="n">threshold</span> <span class="n">can</span> <span class="n">be</span> <span class="n">fulfilled</span> <span class="n">without</span> <span class="n">creating</span> <span class="n">too</span> <span class="n">many</span> <span class="n">heaps</span><span class="o">.</span>  <span class="o">*/</span>

<span class="o">/***************************************************************************/</span>

<span class="o">/*</span> <span class="n">A</span> <span class="n">heap</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">single</span> <span class="n">contiguous</span> <span class="n">memory</span> <span class="n">region</span> <span class="n">holding</span> <span class="p">(</span><span class="n">coalesceable</span><span class="p">)</span>
   <span class="n">malloc_chunks</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">allocated</span> <span class="k">with</span> <span class="n">mmap</span><span class="p">()</span> <span class="ow">and</span> <span class="n">always</span> <span class="n">starts</span> <span class="n">at</span> <span class="n">an</span>
   <span class="n">address</span> <span class="n">aligned</span> <span class="n">to</span> <span class="n">HEAP_MAX_SIZE</span><span class="o">.</span>  <span class="o">*/</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="n">_heap_info</span>
<span class="p">{</span>
  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Arena</span> <span class="k">for</span> <span class="n">this</span> <span class="n">heap</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">struct</span> <span class="n">_heap_info</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Previous</span> <span class="n">heap</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">Current</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">size_t</span> <span class="n">mprotect_size</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span> <span class="n">that</span> <span class="n">has</span> <span class="n">been</span> <span class="n">mprotected</span>
                           <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">.</span>  <span class="o">*/</span>
  <span class="o">/*</span> <span class="n">Make</span> <span class="n">sure</span> <span class="n">the</span> <span class="n">following</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">properly</span> <span class="n">aligned</span><span class="p">,</span> <span class="n">particularly</span>
     <span class="n">that</span> <span class="n">sizeof</span> <span class="p">(</span><span class="n">heap_info</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">multiple</span> <span class="n">of</span>
     <span class="n">MALLOC_ALIGNMENT</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">char</span> <span class="n">pad</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">];</span>
<span class="p">}</span> <span class="n">heap_info</span><span class="p">;</span>
</pre></div>
</div>
<p>该结构主要是描述堆的基本信息，包括</p>
<ul class="simple">
<li>堆对应的 arena 的地址</li>
<li>由于一个线程申请一个堆之后，可能会使用完，之后就必须得再次申请。因此，一个可能会有多个堆。prev即记录了上一个 heap_info 的地址。这里可以看到每个堆的 heap_info 是通过单向链表进行链接的。</li>
<li>size 表示当前堆的大小</li>
<li>最后一部分确保对齐（<strong>这里负数使用的缘由是什么呢</strong>？）</li>
</ul>
<p>看起来该结构应该是相当重要的，但是如果如果我们仔细看完整个 malloc 的实现的话，就会发现它出现的频率并不高。</p>
</div>
<div class="section" id="malloc-state">
<h3>malloc_state<a class="headerlink" href="#malloc-state" title="永久链接至标题">¶</a></h3>
<p>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲chunk，有什么大小的空闲chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的
arena 可能有多个，malloc state结构会在最新申请的arena中。</p>
<p><strong>注意，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p>
<p>其结构如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">malloc_state</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="n">Serialize</span> <span class="n">access</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="n">__libc_lock_define</span><span class="p">(,</span> <span class="n">mutex</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">Flags</span> <span class="p">(</span><span class="n">formerly</span> <span class="ow">in</span> <span class="n">max_fast</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="nb">int</span> <span class="n">flags</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Fastbins</span> <span class="o">*/</span>
    <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span> <span class="n">NFASTBINS</span> <span class="p">];</span>

    <span class="o">/*</span> <span class="n">Base</span> <span class="n">of</span> <span class="n">the</span> <span class="n">topmost</span> <span class="n">chunk</span> <span class="o">--</span> <span class="ow">not</span> <span class="n">otherwise</span> <span class="n">kept</span> <span class="ow">in</span> <span class="n">a</span> <span class="nb">bin</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span> <span class="n">top</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">The</span> <span class="n">remainder</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">most</span> <span class="n">recent</span> <span class="n">split</span> <span class="n">of</span> <span class="n">a</span> <span class="n">small</span> <span class="n">request</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span> <span class="n">last_remainder</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Normal</span> <span class="n">bins</span> <span class="n">packed</span> <span class="k">as</span> <span class="n">described</span> <span class="n">above</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span> <span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">];</span>

    <span class="o">/*</span> <span class="n">Bitmap</span> <span class="n">of</span> <span class="n">bins</span><span class="p">,</span> <span class="n">help</span> <span class="n">to</span> <span class="n">speed</span> <span class="n">up</span> <span class="n">the</span> <span class="n">process</span> <span class="n">of</span> <span class="n">determinating</span> <span class="k">if</span> <span class="n">a</span> <span class="n">given</span> <span class="nb">bin</span> <span class="ow">is</span> <span class="n">definitely</span> <span class="n">empty</span><span class="o">.*/</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">binmap</span><span class="p">[</span> <span class="n">BINMAPSIZE</span> <span class="p">];</span>

    <span class="o">/*</span> <span class="n">Linked</span> <span class="nb">list</span><span class="p">,</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">arena</span> <span class="o">*/</span>
    <span class="n">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Linked</span> <span class="nb">list</span> <span class="k">for</span> <span class="n">free</span> <span class="n">arenas</span><span class="o">.</span>  <span class="n">Access</span> <span class="n">to</span> <span class="n">this</span> <span class="n">field</span> <span class="ow">is</span> <span class="n">serialized</span>
       <span class="n">by</span> <span class="n">free_list_lock</span> <span class="ow">in</span> <span class="n">arena</span><span class="o">.</span><span class="n">c</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="n">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="n">next_free</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">threads</span> <span class="n">attached</span> <span class="n">to</span> <span class="n">this</span> <span class="n">arena</span><span class="o">.</span>  <span class="mi">0</span> <span class="k">if</span> <span class="n">the</span> <span class="n">arena</span> <span class="ow">is</span> <span class="n">on</span>
       <span class="n">the</span> <span class="n">free</span> <span class="nb">list</span><span class="o">.</span>  <span class="n">Access</span> <span class="n">to</span> <span class="n">this</span> <span class="n">field</span> <span class="ow">is</span> <span class="n">serialized</span> <span class="n">by</span>
       <span class="n">free_list_lock</span> <span class="ow">in</span> <span class="n">arena</span><span class="o">.</span><span class="n">c</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">attached_threads</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Memory</span> <span class="n">allocated</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">arena</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">system_mem</span><span class="p">;</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">max_system_mem</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>​ __libc_lock_define(, mutex);<ul>
<li>该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成候才能够使用。</li>
</ul>
</li>
<li>flags<ul>
<li>flags记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。具体如下</li>
</ul>
</li>
</ul>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">FASTCHUNKS_BIT</span> <span class="n">held</span> <span class="ow">in</span> <span class="n">max_fast</span> <span class="n">indicates</span> <span class="n">that</span> <span class="n">there</span> <span class="n">are</span> <span class="n">probably</span>
   <span class="n">some</span> <span class="n">fastbin</span> <span class="n">chunks</span><span class="o">.</span> <span class="n">It</span> <span class="ow">is</span> <span class="nb">set</span> <span class="n">true</span> <span class="n">on</span> <span class="n">entering</span> <span class="n">a</span> <span class="n">chunk</span> <span class="n">into</span> <span class="nb">any</span>
   <span class="n">fastbin</span><span class="p">,</span> <span class="ow">and</span> <span class="n">cleared</span> <span class="n">only</span> <span class="ow">in</span> <span class="n">malloc_consolidate</span><span class="o">.</span>
   <span class="n">The</span> <span class="n">truth</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">inverted</span> <span class="n">so</span> <span class="n">that</span> <span class="n">have_fastchunks</span> <span class="n">will</span> <span class="n">be</span> <span class="n">true</span>
   <span class="n">upon</span> <span class="n">startup</span> <span class="p">(</span><span class="n">since</span> <span class="n">statics</span> <span class="n">are</span> <span class="n">zero</span><span class="o">-</span><span class="n">filled</span><span class="p">),</span> <span class="n">simplifying</span>
   <span class="n">initialization</span> <span class="n">checks</span><span class="o">.</span>
 <span class="o">*/</span>

<span class="c1">#define FASTCHUNKS_BIT (1U)</span>

<span class="c1">#define have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span>
<span class="c1">#define clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span>
<span class="c1">#define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span>

<span class="o">/*</span>
   <span class="n">NONCONTIGUOUS_BIT</span> <span class="n">indicates</span> <span class="n">that</span> <span class="n">MORECORE</span> <span class="n">does</span> <span class="ow">not</span> <span class="k">return</span> <span class="n">contiguous</span>
   <span class="n">regions</span><span class="o">.</span>  <span class="n">Otherwise</span><span class="p">,</span> <span class="n">contiguity</span> <span class="ow">is</span> <span class="n">exploited</span> <span class="ow">in</span> <span class="n">merging</span> <span class="n">together</span><span class="p">,</span>
   <span class="n">when</span> <span class="n">possible</span><span class="p">,</span> <span class="n">results</span> <span class="kn">from</span> <span class="nn">consecutive</span> <span class="n">MORECORE</span> <span class="n">calls</span><span class="o">.</span>
   <span class="n">The</span> <span class="n">initial</span> <span class="n">value</span> <span class="n">comes</span> <span class="kn">from</span> <span class="nn">MORECORE_CONTIGUOUS</span><span class="p">,</span> <span class="n">but</span> <span class="ow">is</span>
   <span class="n">changed</span> <span class="n">dynamically</span> <span class="k">if</span> <span class="n">mmap</span> <span class="ow">is</span> <span class="n">ever</span> <span class="n">used</span> <span class="k">as</span> <span class="n">an</span> <span class="n">sbrk</span> <span class="n">substitute</span><span class="o">.</span>
 <span class="o">*/</span>

<span class="c1">#define NONCONTIGUOUS_BIT (2U)</span>

<span class="c1">#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span>
<span class="c1">#define noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span>
<span class="c1">#define set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span>
<span class="c1">#define set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span>

<span class="o">/*</span> <span class="n">ARENA_CORRUPTION_BIT</span> <span class="ow">is</span> <span class="nb">set</span> <span class="k">if</span> <span class="n">a</span> <span class="n">memory</span> <span class="n">corruption</span> <span class="n">was</span> <span class="n">detected</span> <span class="n">on</span> <span class="n">the</span>
   <span class="n">arena</span><span class="o">.</span>  <span class="n">Such</span> <span class="n">an</span> <span class="n">arena</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">used</span> <span class="n">to</span> <span class="n">allocate</span> <span class="n">chunks</span><span class="o">.</span>  <span class="n">Chunks</span>
   <span class="n">allocated</span> <span class="ow">in</span> <span class="n">that</span> <span class="n">arena</span> <span class="n">before</span> <span class="n">detecting</span> <span class="n">corruption</span> <span class="n">are</span> <span class="ow">not</span> <span class="n">freed</span><span class="o">.</span>  <span class="o">*/</span>

<span class="c1">#define ARENA_CORRUPTION_BIT (4U)</span>

<span class="c1">#define arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span>
<span class="c1">#define set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span>
</pre></div>
</div>
<ul class="simple">
<li>fastbinsY[NFASTBINS]<ul>
<li>存放每个 fast chunk 链表头部的指针</li>
</ul>
</li>
<li>top<ul>
<li>指向分配区的 top chunk</li>
</ul>
</li>
<li>last_reminder<ul>
<li>最新的 chunk 分割之后剩下的那部分</li>
</ul>
</li>
<li>bins<ul>
<li>用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</li>
</ul>
</li>
<li>binmap<ul>
<li>ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。</li>
</ul>
</li>
</ul>
<p>这里 chunk 就是一个内存块。关于其中每一个变量的具体意思，我们会在使用到的时候进行详细地说明。</p>
</div>
<div class="section" id="malloc-par">
<h3>malloc_par<a class="headerlink" href="#malloc-par" title="永久链接至标题">¶</a></h3>
<p><strong>！！待补充！！</strong></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<div class="sphinx-toc sphinxglobaltoc">
<h3><a href="../../index.html">內容目录</a></h3>
<p class="caption"><span class="caption-text">CTF 介绍</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/history.html">CTF 竞赛的历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/mode.html">CTF 竞赛模式简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/content.html">CTF 竞赛内容</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/experience.html">线下攻防经验小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/cgc.html">CGC 网络超级挑战赛</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/resources.html">学习资源</a></li>
</ul>
<p class="caption"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../misc/about.html">杂项简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/recon.html">信息搜集技术</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/encode/index.html">编码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/prefix.html">取证隐写</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/picture/index.html">图片分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/traffic/index.html">流量包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/archive/index.html">压缩包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/audio/index.html">音频分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/disk_memory/index.html">磁盘 / 内存分析</a></li>
</ul>
<p class="caption"><span class="caption-text">Crypto</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/introduction.html">密码学简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/classical/index.html">古典密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/symmetric/index.html">对称加密</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/asymmetric/index.html">非对称密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/hash/index.html">哈希函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/signature/index.html">数字签名</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/others/others.html">证书格式</a></li>
</ul>
<p class="caption"><span class="caption-text">Web</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../web/index.html">WEB 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/sqli.html">SQL 注入</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/xss.html">XSS 跨站脚本攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/csrf.html">CSRF 跨站请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/ssrf.html">SSRF 服务端请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/php.html">PHP 代码审计</a></li>
</ul>
<p class="caption"><span class="caption-text">Reverse</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/introduction.html">软件逆向工程简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/unpack/index.html">Unpack Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/unicorn/index.html">Unicorn Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/anti_debug/index.html">Anti Debug Tech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/linux/index.html">Linux RE</a></li>
</ul>
<p class="caption"><span class="caption-text">Pwn</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../stackoverflow/index.html">栈溢出</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fmtstr/index.html">格式化字符串漏洞</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">堆利用</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="heap_overview.html">堆概述</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">堆相关数据结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview？？？？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">微观结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#malloc-chunk">malloc_chunk</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id3">概述</a></li>
<li class="toctree-l5"><a class="reference internal" href="#chunk">chunk相关宏</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#bin">bin</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id8">概述</a></li>
<li class="toctree-l5"><a class="reference internal" href="#fast-bin">fast bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="#small-bin">small bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="#large-bin">large bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="#unsorted-bin">unsorted bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="#common-macro">common macro</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#top-chunk">top chunk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#last-remainder">last remainder</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id9">宏观结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#arena">arena</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id10">arena 数量</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id11">arena 分配规则</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id12">区别</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#heap-info">heap_info</a></li>
<li class="toctree-l4"><a class="reference internal" href="#malloc-state">malloc_state</a></li>
<li class="toctree-l4"><a class="reference internal" href="#malloc-par">malloc_par</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="heap_implementation_details.html">深入理解堆的实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="heapoverflow_basic.html">堆溢出</a></li>
<li class="toctree-l2"><a class="reference internal" href="off_by_one.html">堆中的 Off-By-One</a></li>
<li class="toctree-l2"><a class="reference internal" href="unlink.html">Unlink</a></li>
<li class="toctree-l2"><a class="reference internal" href="use_after_free.html">Use After Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="fastbin_attack.html">Fastbin Attack</a></li>
<li class="toctree-l2"><a class="reference internal" href="chunk_extend_shrink.html">Chunk Extend/Shrink</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_einherjar.html">House Of Einherjar</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_lore.html">House of Lore</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_force.html">House Of Force</a></li>
<li class="toctree-l2"><a class="reference internal" href="unsorted_bin_attack.html">Unsorted Bin Attack</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Executable</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../executable/elf/index.html">ELF文件</a></li>
</ul>
</div>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../index.html" title="內容目录"
             >toc</a></li>
        <li class="right" >
          <a href="heap_implementation_details.html" title="深入理解堆的实现"
             >下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="heap_overview.html" title="堆概述"
             >上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">CTF Wiki </a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >堆利用</a> &#187;</li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2017, CTF Wiki.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7 创建。
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>