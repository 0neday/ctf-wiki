


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>深入理解堆的实现 &#8212; CTF Wiki </title>
    <link rel="stylesheet" href="../../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../_static/cloud.base.js"></script>
    <script type="text/javascript" src="../../_static/cloud.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="堆溢出" href="heapoverflow_basic.html" />
    <link rel="prev" title="堆相关数据结构" href="heap_structure.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../index.html" title="內容目录"
             accesskey="C">toc</a></li>
        <li class="right" >
          <a href="heapoverflow_basic.html" title="堆溢出"
             accesskey="N">下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="heap_structure.html" title="堆相关数据结构"
             accesskey="P">上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">CTF Wiki </a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">堆利用</a> &#187;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>深入理解堆的实现<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>仔细想一下，任何堆的实现都离不开以下两个方面的问题</p>
<ul class="simple">
<li>宏观角度<ul>
<li>创建堆</li>
<li>堆初始化</li>
<li>删除堆</li>
</ul>
</li>
<li>微观角度<ul>
<li>申请内存块</li>
<li>释放内存块</li>
</ul>
</li>
</ul>
<p>当然，这些都还是比较高层面的想法，不同的堆的底层的实现会有所不同。</p>
<div class="section" id="id2">
<h2>堆实现概览<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="id3">
<h2>堆初始化<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。这里不做过多讲解。可以参见 <code class="docutils literal"><span class="pre">malloc_state</span> <span class="pre">相关函数</span></code>。</p>
</div>
<div class="section" id="id4">
<h2>创建堆<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="id5">
<h2>双向链表相关操作<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<div class="section" id="unlink">
<h3>unlink<a class="headerlink" href="#unlink" title="永久链接至标题">¶</a></h3>
<p>unlink 用来将一个双向 bin 链表中的一个 chunk 取出来，可能在以下地方使用</p>
<ul class="simple">
<li>malloc<ul>
<li>从恰好大小合适的 large bin 中获取 chunk。<ul>
<li><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</strong></li>
<li>依次遍历处理unsorted bin时也是没有unlink的。</li>
</ul>
</li>
<li>从比所需要的 chunk 相应的 bin 大的 bin 中取 chunk。</li>
</ul>
</li>
<li>Free<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li>malloc_consolidate<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li>realloc<ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了top chunk）。</li>
</ul>
</li>
</ul>
<p>由于 unlink 使用非常频繁，所以 unlink 被实现为了一个宏，如下</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/* Take a chunk off a bin list */
##define unlink(AV, P, BK, FD) {                                            \
    // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);               \
    FD = P-&gt;fd;                                                                      \
    BK = P-&gt;bk;                                                                      \
    // 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \
      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \
    else {                                                                      \
        FD-&gt;bk = BK;                                                              \
        BK-&gt;fd = FD;                                                              \
        // 下面主要考虑 P 对应的 nextsize 双向链表的修改
        if (!in_smallbin_range (chunksize_nomask (P))                              \
            // 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 largbin 链表中。
            // 那么其实也就没有必要对 nextsize 字段进行修改了。
            // 这里没有去判断 bk_nextsize 字段，可能会出问题。
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {                      \
            // 类似于小的 chunk 的检查思路
            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)              \
                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \
              malloc_printerr (check_action,                                      \
                               &quot;corrupted double-linked list (not small)&quot;,    \
                               P, AV);                                              \
            // 这里说明 P 已经在 nextsize 链表中了。
            // 如果 FD 没有在 nextsize 链表中
            if (FD-&gt;fd_nextsize == NULL) {                                      \
                // 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P
                // 令 FD 为 nextsize 串起来的
                if (P-&gt;fd_nextsize == P)                                      \
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \
                else {                                                              \
                // 否则我们需要将 FD 插入到 nextsize 形成的双链表中
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \
                  }                                                              \
              } else {                                                              \
                // 如果在的话，直接拿走即可
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \
              }                                                                      \
          }                                                                      \
      }                                                                              \
}
</pre></div>
</div>
<p>这里我们只是以 small bin 的 unlink 为例子介绍一下。对于 large bin 的 unlink，与其类似，只是多了一个nextsize 的处理。</p>
<p><img alt="image0" src="../../_images/unlink_smallbin_intro.png" /></p>
<p>可以看出， <strong>P 最后的 fd 和 bk 指针并没有发生变化</strong>，但是当我们去遍历整个双向链表时，已经遍历不到对应的链表了。这一点没有变化还是很有用处的。</p>
<p>同时，对于无论是对于 fd，bk 还是 fd_nextsize ，bk_nextsize，程序都做了相应的检测。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">fd</span> <span class="n">bk</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">P</span> <span class="o">||</span> <span class="n">BK</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                      \
  <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="s2">&quot;corrupted double-linked list&quot;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">AV</span><span class="p">);</span>  \

  <span class="o">//</span> <span class="n">next_size</span> <span class="n">related</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>              \
                <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">P</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>    \
              <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span>                                      \
                               <span class="s2">&quot;corrupted double-linked list (not small)&quot;</span><span class="p">,</span>    \
                               <span class="n">P</span><span class="p">,</span> <span class="n">AV</span><span class="p">);</span>
</pre></div>
</div>
<p>看起来似乎很正常。我们以 fd 和 bk 为例，P 的 forward chunk 的 bk 很自然是 P ，同样 P 的 backward chunk 的 fd 也很自然是 P 。如果没有做相应的检查的话，我们可以修改 P 的 fd 与
bk，从而可以很容易地达到任意地址写的效果。关于更加详细的例子，可以参见利用部分的 unlink 。</p>
<p><strong>注意：堆的第一个chunk的话所记录的prev_inuse位默认为1。</strong></p>
</div>
</div>
<div class="section" id="id6">
<h2>申请内存块<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>我们之前也说了，我们会使用 malloc 函数来申请内存块，可是当我们仔细看看 glibc 的源码实现时，其实并没有malloc 函数。其实该函数真正调用的是 __libc_malloc 函数。为什么不直接写个 malloc
函数呢，因为有时候我们可能需要不同的名称。此外，__libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。下面我们来仔细分析一下实现。</p>
<div class="section" id="libc-malloc">
<h3>__libc_malloc<a class="headerlink" href="#libc-malloc" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>该函数会首先检查是否有内存分配函数的钩子函数（__malloc_hook）。该函数主要用于进程在创建新线程过程中分配内存或者用户自定义的分配函数。这里需要注意的是，<strong>用户申请的字节一旦进入申请内存函数中就变成了无符号整数</strong>。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>// wapper for int_malloc
void *__libc_malloc(size_t bytes) {
    mstate ar_ptr;
    void * victim;
    // 检查是否有内存分配钩子，如果有，调用钩子并返回.
    void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook);
    if (__builtin_expect(hook != NULL, 0))
        return (*hook)(bytes, RETURN_ADDRESS(0));
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>接着会寻找一个 arena 来试图分配内存。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">arena_get</span><span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>然后调用 _int_malloc 函数去申请对应的内存。</li>
</ol>
<div class="code c++ highlight-default"><div class="highlight"><pre><span></span><span class="n">victim</span> <span class="o">=</span> <span class="n">_int_malloc</span><span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Retry with another arena only if we were able to find a usable arena
   before.  */
if (!victim &amp;&amp; ar_ptr != NULL) {
    LIBC_PROBE(memory_malloc_retry, 1, bytes);
    ar_ptr = arena_get_retry(ar_ptr, bytes);
    victim = _int_malloc(ar_ptr, bytes);
}
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li>如果申请到了arena，那么在退出之前还得解锁。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">ar_ptr</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="n">__libc_lock_unlock</span><span class="p">(</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="6">
<li>判断目前的状态是否满足以下条件，要么没有申请到内存，要么是 mmap 的内存，<strong>要么申请到的内存必须在其所分配的arena中</strong>。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||
       ar_ptr == arena_for_chunk(mem2chunk(victim)));
</pre></div>
</div>
<ol class="arabic simple" start="7">
<li>最后返回内存。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">victim</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="int-malloc">
<h3>_int_malloc<a class="headerlink" href="#int-malloc" title="永久链接至标题">¶</a></h3>
<p>_int_malloc 是内存分配的核心函数，其核心思路有如下</p>
<ol class="arabic simple">
<li>它根据用户申请的内存块的大小以及相应大小 chunk 使用的频度（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li>
<li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足需求。</li>
<li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li>
<li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li>
</ol>
<p>在进入该函数后，函数立马定义了一系列自己需要的变量，并将用户申请的内存大小转换为内部的chunk大小。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="o">*</span><span class="n">_int_malloc</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">bytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">nb</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">normalized</span> <span class="n">request</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="n">unsigned</span> <span class="nb">int</span>    <span class="n">idx</span><span class="p">;</span> <span class="o">/*</span> <span class="n">associated</span> <span class="nb">bin</span> <span class="n">index</span> <span class="o">*/</span>
    <span class="n">mbinptr</span>         <span class="nb">bin</span><span class="p">;</span> <span class="o">/*</span> <span class="n">associated</span> <span class="nb">bin</span> <span class="o">*/</span>

    <span class="n">mchunkptr</span>       <span class="n">victim</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">inspected</span><span class="o">/</span><span class="n">selected</span> <span class="n">chunk</span> <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">its</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="nb">int</span>             <span class="n">victim_index</span><span class="p">;</span> <span class="o">/*</span> <span class="n">its</span> <span class="nb">bin</span> <span class="n">index</span> <span class="o">*/</span>

    <span class="n">mchunkptr</span>     <span class="n">remainder</span><span class="p">;</span>      <span class="o">/*</span> <span class="n">remainder</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">split</span> <span class="o">*/</span>
    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">remainder_size</span><span class="p">;</span> <span class="o">/*</span> <span class="n">its</span> <span class="n">size</span> <span class="o">*/</span>

    <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">block</span><span class="p">;</span> <span class="o">/*</span> <span class="n">bit</span> <span class="nb">map</span> <span class="n">traverser</span> <span class="o">*/</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">bit</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">bit</span> <span class="nb">map</span> <span class="n">traverser</span> <span class="o">*/</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="nb">map</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">current</span> <span class="n">word</span> <span class="n">of</span> <span class="n">binmap</span> <span class="o">*/</span>

    <span class="n">mchunkptr</span> <span class="n">fwd</span><span class="p">;</span> <span class="o">/*</span> <span class="n">misc</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">linking</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span> <span class="n">bck</span><span class="p">;</span> <span class="o">/*</span> <span class="n">misc</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">linking</span> <span class="o">*/</span>

    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">errstr</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

    <span class="o">/*</span>
       <span class="n">Convert</span> <span class="n">request</span> <span class="n">size</span> <span class="n">to</span> <span class="n">internal</span> <span class="n">form</span> <span class="n">by</span> <span class="n">adding</span> <span class="n">SIZE_SZ</span> <span class="nb">bytes</span>
       <span class="n">overhead</span> <span class="n">plus</span> <span class="n">possibly</span> <span class="n">more</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">necessary</span> <span class="n">alignment</span> <span class="ow">and</span><span class="o">/</span><span class="ow">or</span>
       <span class="n">to</span> <span class="n">obtain</span> <span class="n">a</span> <span class="n">size</span> <span class="n">of</span> <span class="n">at</span> <span class="n">least</span> <span class="n">MINSIZE</span><span class="p">,</span> <span class="n">the</span> <span class="n">smallest</span> <span class="n">allocatable</span>
       <span class="n">size</span><span class="o">.</span> <span class="n">Also</span><span class="p">,</span> <span class="n">checked_request2size</span> <span class="n">traps</span> <span class="p">(</span><span class="n">returning</span> <span class="mi">0</span><span class="p">)</span> <span class="n">request</span> <span class="n">sizes</span>
       <span class="n">that</span> <span class="n">are</span> <span class="n">so</span> <span class="n">large</span> <span class="n">that</span> <span class="n">they</span> <span class="n">wrap</span> <span class="n">around</span> <span class="n">zero</span> <span class="n">when</span> <span class="n">padded</span> <span class="ow">and</span>
       <span class="n">aligned</span><span class="o">.</span>
     <span class="o">*/</span>

    <span class="n">checked_request2size</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="arena">
<h4>arena<a class="headerlink" href="#arena" title="永久链接至标题">¶</a></h4>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">There</span> <span class="n">are</span> <span class="n">no</span> <span class="n">usable</span> <span class="n">arenas</span><span class="o">.</span>  <span class="n">Fall</span> <span class="n">back</span> <span class="n">to</span> <span class="n">sysmalloc</span> <span class="n">to</span> <span class="n">get</span> <span class="n">a</span> <span class="n">chunk</span> <span class="kn">from</span>
   <span class="nn">mmap.</span>  <span class="o">*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sysmalloc</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="fast-bin">
<h4>fast bin<a class="headerlink" href="#fast-bin" title="永久链接至标题">¶</a></h4>
<p>如果申请的 chunk 的大小位于 fastbin 范围内，<strong>需要注意的是这里比较的是无符号整数</strong>。<strong>此外，是从 fastbin 的头结点开始取 chunk</strong>。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   If the size qualifies as a fastbin, first check corresponding bin.
   This code is safe to execute even if av is not yet initialized, so we
   can try it without checking, which saves some time on this fast path.
 */

if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast())) {
    // 得到对应的fastbin的下标
    idx             = fastbin_index(nb);
    // 得到对应的fastbin的头指针
    mfastbinptr *fb = &amp;fastbin(av, idx);
    mchunkptr    pp = *fb;
    // 利用fd遍历对应的bin内是否有空闲的chunk块，
    do {
        victim = pp;
        if (victim == NULL) break;
    } while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,
                                                        victim)) != victim);
    // 存在可以利用的chunk
    if (victim != 0) {
        // 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。
        // 根据取得的 victim ，利用 chunksize 计算其大小。
        // 利用fastbin_index 计算 chunk 的索引。
        if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) {
            errstr = &quot;malloc(): memory corruption (fast)&quot;;
        errout:
            malloc_printerr(check_action, errstr, chunk2mem(victim), av);
            return NULL;
        }
        // 细致的检查。。只有在 DEBUG 的时候有用
        check_remalloced_chunk(av, victim, nb);
        // 将获取的到chunk转换为mem模式
        void *p = chunk2mem(victim);
        // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
        alloc_perturb(p, bytes);
        return p;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="small-bin">
<h4>small bin<a class="headerlink" href="#small-bin" title="永久链接至标题">¶</a></h4>
<p>如果获取的内存块的范围处于 small bin 的范围，那么执行如下流程</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   If a small request, check regular bin.  Since these &quot;smallbins&quot;
   hold one size each, no searching within bins is necessary.
   (For a large request, we need to wait until unsorted chunks are
   processed to find best fit. But for small ones, fits are exact
   anyway, so we can check now, which is faster.)
 */

if (in_smallbin_range(nb)) {
    // 获取 small bin 的索引
    idx = smallbin_index(nb);
    // 获取对应 small bin 中的 chunk 指针
    bin = bin_at(av, idx);
    // 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk
    // 如果 victim = bin ，那说明该 bin 为空。
    // 如果不相等，那么会有两种情况
    if ((victim = last(bin)) != bin) {
        // 第一种情况，small bin 还没有初始化。
        if (victim == 0) /* initialization check */
            // 执行初始化，将 fast bins 中的 chunk 进行合并
            malloc_consolidate(av);
        // 第二种情况，small bin 中存在空闲的 chunk
        else {
            // 获取 small bin 中倒数第二个 chunk 。
            bck = victim-&gt;bk;
            // 检查 bck-&gt;fd 是不是 victim，防止伪造
            if (__glibc_unlikely(bck-&gt;fd != victim)) {
                errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;
                goto errout;
            }
            // 设置 victim 对应的 inuse 位
            set_inuse_bit_at_offset(victim, nb);
            // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来
            bin-&gt;bk = bck;
            bck-&gt;fd = bin;
            // 如果不是 main_arena，设置对应的标志
            if (av != &amp;main_arena) set_non_main_arena(victim);
            // 细致的检查，非调试状态没有作用
            check_malloced_chunk(av, victim, nb);
            // 将申请到的 chunk 转化为对应的 mem 状态
            void *p = chunk2mem(victim);
            // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff
            alloc_perturb(p, bytes);
            return p;
        }
    }
}
</pre></div>
</div>
</div>
<div class="section" id="large-bin">
<h4>large bin<a class="headerlink" href="#large-bin" title="永久链接至标题">¶</a></h4>
<p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的chunk，而是先利用
malloc_consolidate（参见malloc_state相关函数） 函数处理 fast bin 中的chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin
中，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   If this is a large request, consolidate fastbins before continuing.
   While it might look excessive to kill all fastbins before
   even seeing if there is space available, this avoids
   fragmentation problems normally associated with fastbins.
   Also, in practice, programs tend to have runs of either small or
   large requests, but less often mixtures, so consolidation is not
   invoked all that often in most programs. And the programs that
   it is called frequently in otherwise tend to fragment.
 */

else {
    // 获取large bin的下标。
    idx = largebin_index(nb);
    // 如果存在fastbin的话，会处理 fastbin
    if (have_fastchunks(av)) malloc_consolidate(av);
}
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>大循环<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p><strong>如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk可以直接满足需求 ，但是large chunk 则是在这个大循环中处理</strong>。</p>
<p>在接下来的这个循环中，主要做了以下的操作</p>
<ul class="simple">
<li>尝试从 unsorted bin 中分配用户所需的内存</li>
<li>尝试从 large bin 中分配用户所需的内存</li>
<li>尝试从 top chunk 中分配用户所需内存</li>
</ul>
<p>该部分是一个大循环，这是为了尝试重新分配 small bin chunk，这是因为我们虽然会首先使用 large bin，top chunk 来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功 small
bin，我们并没有对fast bin 中的 chunk 进行合并，所以这里会进行 fast bin chunk 的合并，进而使用一个大循环来尝试再次分配small bin chunk。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Process</span> <span class="n">recently</span> <span class="n">freed</span> <span class="ow">or</span> <span class="n">remaindered</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">taking</span> <span class="n">one</span> <span class="n">only</span> <span class="k">if</span>
   <span class="n">it</span> <span class="ow">is</span> <span class="n">exact</span> <span class="n">fit</span><span class="p">,</span> <span class="ow">or</span><span class="p">,</span> <span class="k">if</span> <span class="n">this</span> <span class="n">a</span> <span class="n">small</span> <span class="n">request</span><span class="p">,</span> <span class="n">the</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="n">remainder</span> <span class="kn">from</span>
   <span class="nn">the</span> <span class="n">most</span> <span class="n">recent</span> <span class="n">non</span><span class="o">-</span><span class="n">exact</span> <span class="n">fit</span><span class="o">.</span>  <span class="n">Place</span> <span class="n">other</span> <span class="n">traversed</span> <span class="n">chunks</span> <span class="ow">in</span>
   <span class="n">bins</span><span class="o">.</span>  <span class="n">Note</span> <span class="n">that</span> <span class="n">this</span> <span class="n">step</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">only</span> <span class="n">place</span> <span class="ow">in</span> <span class="nb">any</span> <span class="n">routine</span> <span class="n">where</span>
   <span class="n">chunks</span> <span class="n">are</span> <span class="n">placed</span> <span class="ow">in</span> <span class="n">bins</span><span class="o">.</span>

   <span class="n">The</span> <span class="n">outer</span> <span class="n">loop</span> <span class="n">here</span> <span class="ow">is</span> <span class="n">needed</span> <span class="n">because</span> <span class="n">we</span> <span class="n">might</span> <span class="ow">not</span> <span class="n">realize</span> <span class="n">until</span>
   <span class="n">near</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">malloc</span> <span class="n">that</span> <span class="n">we</span> <span class="n">should</span> <span class="n">have</span> <span class="n">consolidated</span><span class="p">,</span> <span class="n">so</span> <span class="n">must</span>
   <span class="n">do</span> <span class="n">so</span> <span class="ow">and</span> <span class="n">retry</span><span class="o">.</span> <span class="n">This</span> <span class="n">happens</span> <span class="n">at</span> <span class="n">most</span> <span class="n">once</span><span class="p">,</span> <span class="ow">and</span> <span class="n">only</span> <span class="n">when</span> <span class="n">we</span> <span class="n">would</span>
   <span class="n">otherwise</span> <span class="n">need</span> <span class="n">to</span> <span class="n">expand</span> <span class="n">memory</span> <span class="n">to</span> <span class="n">service</span> <span class="n">a</span> <span class="s2">&quot;small&quot;</span> <span class="n">request</span><span class="o">.</span>
 <span class="o">*/</span>

<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="unsort-bin">
<h5>unsort bin 遍历<a class="headerlink" href="#unsort-bin" title="永久链接至标题">¶</a></h5>
<p>先考虑 unsorted bin，再考虑 last remainder ，但是对于small bin chunk 的请求会有所例外。</p>
<p><strong>注意 unsorted bin 的遍历顺序为 bk。</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>// 如果 unsorted bin 不为空
// First In First Out
while ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) {
    // victim 为 unsorted bin 的最后一个 chunk
    // bck 为 unsorted bin 的倒数第二个 chunk
    bck = victim-&gt;bk;
    // 判断得到的 chunk 是否满足要求，不能过小，也不能过大
    // 一般 system_mem 的大小为132K
    if (__builtin_expect(chunksize_nomask(victim) &lt;= 2 * SIZE_SZ, 0) ||
        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, 0))
        malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,
                        chunk2mem(victim), av);
    // 得到victim对应的chunk大小。
    size = chunksize(victim);
</pre></div>
</div>
<p>small request</p>
<p>如果用户的请求为 small bin chunk，那么我们首先考虑 last remainder，如果 last remainder 是 unsorted bin 中的唯一一块的话， 并且 last remainder 的大小分割够还可以作为一个 chunk
，<strong>为什么没有等号</strong>？</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/*
   If a small request, try to use last remainder if it is the
   only chunk in unsorted bin.  This helps promote locality for
   runs of consecutive small requests. This is the only
   exception to best-fit, and applies only when there is
   no exact fit for a small chunk.
 */

if (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;
    victim == av-&gt;last_remainder &amp;&amp;
    (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) {
    /* split and reattach remainder */
    // 获取新的 remainder 的大小
    remainder_size          = size - nb;
    // 获取新的 remainder 的位置
    remainder               = chunk_at_offset(victim, nb);
    // 更新 unsorted bin 的情况
    unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;
    // 更新 av 中记录的 last_remainder
    av-&gt;last_remainder                                = remainder;
    // 更新last remainder的指针
    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);
    if (!in_smallbin_range(remainder_size)) {
        remainder-&gt;fd_nextsize = NULL;
        remainder-&gt;bk_nextsize = NULL;
    }
    // 设置victim的头部，
    set_head(victim, nb | PREV_INUSE |
                         (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
    // 设置 remainder 的头部
    set_head(remainder, remainder_size | PREV_INUSE);
    // 设置记录 remainder 大小的 prev_size 字段，因为此时 remainder 处于空闲状态。
    set_foot(remainder, remainder_size);
    // 细致的检查，非调试状态下没有作用
    check_malloced_chunk(av, victim, nb);
    // 将 victim 从 chunk 模式转化为mem模式
    void *p = chunk2mem(victim);
    // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
    alloc_perturb(p, bytes);
    return p;
}
</pre></div>
</div>
<p>初始取出</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">remove</span> <span class="kn">from</span> <span class="nn">unsorted</span> <span class="nb">list</span> <span class="o">*/</span>
<span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
<span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span>                 <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
</pre></div>
</div>
<p>exact fit</p>
<p>如果从 unsorted bin 中取出来的 chunk 大小正好合适，就直接使用。这里应该已经把合并后恰好合适的 chunk 给分配出去了。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Take</span> <span class="n">now</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">binning</span> <span class="k">if</span> <span class="n">exact</span> <span class="n">fit</span> <span class="o">*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set_inuse_bit_at_offset</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="n">set_non_main_arena</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
    <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
    <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>place chunk in small bin</p>
<p>把取出来的 chunk 放到对应的 small bin 中。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">place</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">bin</span> <span class="o">*/</span>

<span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">victim_index</span> <span class="o">=</span> <span class="n">smallbin_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">bck</span>          <span class="o">=</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>
    <span class="n">fwd</span>          <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</pre></div>
</div>
<p>place chunk in large bin</p>
<p>把取出来的 chunk 放到对应的 large bin 中。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>} else {
    // large bin范围
    victim_index = largebin_index(size);
    bck          = bin_at(av, victim_index);
    fwd          = bck-&gt;fd;

    /* maintain large bins in sorted order */
    /* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。
       同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，
       而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，
       可以减低开销。此外，bin 头不参与 nextsize 链接。*/
    // 如果 large bin 链表不空
    if (fwd != bck) {
        /* Or with inuse bit to speed comparisons */
        // 加速比较，应该不仅仅有这个考虑，因为链表里的chunk都会设置该位。
        size |= PREV_INUSE;
        /* if smaller than smallest, bypass loop below */
        // bck-bk 存储着相应 large bin 中最小的chunk。
        // 如果遍历的chunk比当前最小的还要小，那就只需要插入到链表尾部。
        // 判断 bck-&gt;bk 是不是在 main arena。
        assert(chunk_main_arena(bck-&gt;bk));
        if ((unsigned long) (size) &lt;
            (unsigned long) chunksize_nomask(bck-&gt;bk)) {
            // 令 fwd 指向 bin 头
            fwd = bck;
            // 令 bck 指向 bin 尾
            bck = bck-&gt;bk;
            // victim 的 fd_nextsize 指向链表的第一个 chunk
            victim-&gt;fd_nextsize = fwd-&gt;fd;
            // victim 的 bk_nextsize 指向原来链表的第一个chunk 指向的bk_nextsize
            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;
            // 原来链表的第一个 chunk 的 bk_nextsize 指向 victim
            // 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim
            fwd-&gt;fd-&gt;bk_nextsize =
                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
        } else {
            // 当前要插入的 victim 的大小大于最小的 chunk
            // 判断 fwd 是否在 main arena
            assert(chunk_main_arena(fwd));
            // 从链表头部开始找到不比 victim 大的 chunk
            while ((unsigned long) size &lt; chunksize_nomask(fwd)) {
                fwd = fwd-&gt;fd_nextsize;
                assert(chunk_main_arena(fwd));
            }
            // 如果找到了一个和 victim 一样大的 chunk，
            // 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。
            if ((unsigned long) size ==
                (unsigned long) chunksize_nomask(fwd))
                /* Always insert in the second position.  */
                fwd = fwd-&gt;fd;
            else {
                // 如果找到的chunk和当前victim大小不一样
                // 那么久需要构造 nextsize 双向链表了
                victim-&gt;fd_nextsize              = fwd;
                victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;
                fwd-&gt;bk_nextsize                 = victim;
                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
            }
            bck = fwd-&gt;bk;
        }
    } else
        // 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。
        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;
}
</pre></div>
</div>
<p>最终取出</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>// 放到对应的 bin 中，构成 bk&lt;--&gt;victim&lt;--&gt;fwd。
mark_bin(av, victim_index);
victim-&gt;bk = bck;
victim-&gt;fd = fwd;
fwd-&gt;bk    = victim;
bck-&gt;fd    = victim;
</pre></div>
</div>
<p>while 迭代次数</p>
<p>while 最多迭代10000次后退出。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>            <span class="o">//</span>
<span class="c1">##define MAX_ITERS 10000</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">iters</span> <span class="o">&gt;=</span> <span class="n">MAX_ITERS</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="large-chunk">
<h5>large chunk<a class="headerlink" href="#large-chunk" title="永久链接至标题">¶</a></h5>
<p><strong>注： 或许会很奇怪，为什么这里没有先去看 small chunk 是否满足新需求了呢？这是因为small bin 在循环之前已经判断过了，这里如果有的话，就是合并后的才出现chunk。但是在大循环外，large chunk
只是单纯地找到其索引，所以觉得在这里直接先判断是合理的，而且也为了下面可以再去找较大的chunk。</strong></p>
<p>如果请求的 chunk 在 large chunk 范围内，就在对应的 bin 中从小到大进行扫描，找到第一个合适的。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   If a large request, scan through the chunks of current bin in
   sorted order to find smallest that fits.  Use the skip list for this.
 */
if (!in_smallbin_range(nb)) {
    bin = bin_at(av, idx);
    /* skip scan if empty or largest chunk is too small */
    // 如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过
    // first(bin)=bin-&gt;fd 表示当前链表中最大的chunk
    if ((victim = first(bin)) != bin &amp;&amp;
        (unsigned long) chunksize_nomask(victim) &gt;=
            (unsigned long) (nb)) {
        // 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk
        victim = victim-&gt;bk_nextsize;
        while (((unsigned long) (size = chunksize(victim)) &lt;
                (unsigned long) (nb)))
            victim = victim-&gt;bk_nextsize;

        /* Avoid removing the first entry for a size so that the skip
           list does not have to be rerouted.  */
        // 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk
        // 的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize
        //  链表。因为大小相同的chunk只有一个会被串在nextsize链上。
        if (victim != last(bin) &amp;&amp;
            chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))
            victim = victim-&gt;fd;
        // 计算分配后剩余的大小
        remainder_size = size - nb;
        // 进行unlink
        unlink(av, victim, bck, fwd);

        /* Exhaust */
        // 剩下的大小不足以当做一个块
        // 很好奇接下来会怎么办？
        if (remainder_size &lt; MINSIZE) {
            set_inuse_bit_at_offset(victim, size);
            if (av != &amp;main_arena) set_non_main_arena(victim);
        }
        /* Split */
        //  剩下的大小还可以作为一个chunk，进行分割。
        else {
            // 获取剩下那部分chunk的指针，称为remainder
            remainder = chunk_at_offset(victim, nb);
            /* We cannot assume the unsorted list is empty and therefore
               have to perform a complete insert here.  */
            // 插入unsorted bin中
            bck = unsorted_chunks(av);
            fwd = bck-&gt;fd;
            // 判断 unsorted bin 是否被破坏。
            if (__glibc_unlikely(fwd-&gt;bk != bck)) {
                errstr = &quot;malloc(): corrupted unsorted chunks&quot;;
                goto errout;
            }
            remainder-&gt;bk = bck;
            remainder-&gt;fd = fwd;
            bck-&gt;fd       = remainder;
            fwd-&gt;bk       = remainder;
            // 如果不处于small bin范围内，就设置对应的字段
            if (!in_smallbin_range(remainder_size)) {
                remainder-&gt;fd_nextsize = NULL;
                remainder-&gt;bk_nextsize = NULL;
            }
            // 设置分配的chunk的标记
            set_head(victim,
                     nb | PREV_INUSE |
                         (av != &amp;main_arena ? NON_MAIN_ARENA : 0));

            // 设置remainder的上一个chunk，即分配出去的chunk的使用状态
            // 其余的不用管，直接从上面继承下来了
            set_head(remainder, remainder_size | PREV_INUSE);
            // 设置remainder的大小
            set_foot(remainder, remainder_size);
        }
        // 检查
        check_malloced_chunk(av, victim, nb);
        // 转换为mem状态
        void *p = chunk2mem(victim);
        // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
        alloc_perturb(p, bytes);
        return p;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="chunk">
<h5>寻找较大 chunk<a class="headerlink" href="#chunk" title="永久链接至标题">¶</a></h5>
<p>如果走到了这里，那说明对于用户所需的chunk，不能直接从其对应的合适的bin中获取chunk，所以我们需要来查找比当前 bin 更大的 fast bin ， small bin 或者 large bin。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   Search for a chunk by scanning bins, starting with next largest
   bin. This search is strictly by best-fit; i.e., the smallest
   (with ties going to approximately the least recently used) chunk
   that fits is selected.

   The bitmap avoids needing to check that most blocks are nonempty.
   The particular case of skipping all bins during warm-up phases
   when no chunks have been returned yet is faster than it might look.
 */

++idx;
// 获取对应的bin
bin   = bin_at(av, idx);
// 获取当前索引在binmap中的block索引
// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5
// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在
// 所以这里是右移5
block = idx2block(idx);
// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块
map   = av-&gt;binmap[ block ];
// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))
// 将idx对应的比特位设置为1，其它位为0
bit   = idx2bit(idx);
for (;;) {
</pre></div>
</div>
<p>找到一个合适的 map</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Skip rest of block if there are no more set bits in this block.
 */
// 如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块
// 如果bit为0，那么说明，上面idx2bit带入的参数为0。
if (bit &gt; map || bit == 0) {
    do {
        // 寻找下一个block，直到其对应的map不为0。
        // 如果已经不存在的话，那就只能使用top chunk了
        if (++block &gt;= BINMAPSIZE) /* out of bins */
            goto use_top;
    } while ((map = av-&gt;binmap[ block ]) == 0);
    // 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且
    // map本身不为0，所以必然存在满足需求的chunk。
    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));
    bit = 1;
}
</pre></div>
</div>
<p>找到合适的 bin</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/* Advance to bin with set bit. There must be one. */
// 从当前map的最小的bin一直找，直到找到合适的bin。
// 这里是一定存在的
while ((bit &amp; map) == 0) {
    bin = next_bin(bin);
    bit &lt;&lt;= 1;
    assert(bit != 0);
}
</pre></div>
</div>
<p>简单检查 chunk</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/* Inspect the bin. It is likely to be non-empty */
// 获取对应的bin
victim = last(bin);

/*  If a false alarm (empty bin), clear the bit. */
// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin
// 这种情况发生的概率应该很小。
if (victim == bin) {
    av-&gt;binmap[ block ] = map &amp;= ~bit; /* Write through */
    bin                 = next_bin(bin);
    bit &lt;&lt;= 1;
}
</pre></div>
</div>
<p>真正取出chunk</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>else {
    // 获取对应victim的大小
    size = chunksize(victim);

    /*  We know the first chunk in this bin is big enough to use. */
    assert((unsigned long) (size) &gt;= (unsigned long) (nb));
    // 计算分割后剩余的大小
    remainder_size = size - nb;

    /* unlink */
    unlink(av, victim, bck, fwd);

    /* Exhaust */
    // 如果分割后不够一个chunk怎么办？
    if (remainder_size &lt; MINSIZE) {
        set_inuse_bit_at_offset(victim, size);
        if (av != &amp;main_arena) set_non_main_arena(victim);
    }

    /* Split */
    // 如果够，尽管分割
    else {
        // 计算剩余的chunk的偏移
        remainder = chunk_at_offset(victim, nb);

        /* We cannot assume the unsorted list is empty and therefore
           have to perform a complete insert here.  */
        // 将剩余的chunk插入到unsorted bin中
        bck = unsorted_chunks(av);
        fwd = bck-&gt;fd;
        if (__glibc_unlikely(fwd-&gt;bk != bck)) {
            errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;
            goto errout;
        }
        remainder-&gt;bk = bck;
        remainder-&gt;fd = fwd;
        bck-&gt;fd       = remainder;
        fwd-&gt;bk       = remainder;

        /* advertise as last remainder */
        // 如果在small bin范围内，就将其标记为remainder
        if (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;
        if (!in_smallbin_range(remainder_size)) {
            remainder-&gt;fd_nextsize = NULL;
            remainder-&gt;bk_nextsize = NULL;
        }
        // 设置victim的使用状态
        set_head(victim,
                 nb | PREV_INUSE |
                     (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
        // 设置remainder的使用状态，这里是为什么呢？
        set_head(remainder, remainder_size | PREV_INUSE);
        // 设置remainder的大小
        set_foot(remainder, remainder_size);
    }
    // 检查
    check_malloced_chunk(av, victim, nb);
    // chunk状态转换到mem状态
    void *p = chunk2mem(victim);
    // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
    alloc_perturb(p, bytes);
    return p;
}
</pre></div>
</div>
</div>
<div class="section" id="top-chunk">
<h5>使用 top chunk<a class="headerlink" href="#top-chunk" title="永久链接至标题">¶</a></h5>
<p>如果所有的 bin 中的 chunk 都没有办法直接满足要求（即不合并），或者说都没有空闲的 chunk。那么我们就只能使用 top chunk 了。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>use_top:
    /*
       If large enough, split off the chunk bordering the end of memory
       (held in av-&gt;top). Note that this is in accord with the best-fit
       search rule.  In effect, av-&gt;top is treated as larger (and thus
       less well fitting) than any other available chunk since it can
       be extended to be as large as necessary (up to system
       limitations).

       We require that av-&gt;top always exists (i.e., has size &gt;=
       MINSIZE) after initialization, so if it would otherwise be
       exhausted by current request, it is replenished. (The main
       reason for ensuring it exists is that we may need MINSIZE space
       to put in fenceposts in sysmalloc.)
     */
    // 获取当前的top chunk，并计算其对应的大小
    victim = av-&gt;top;
    size   = chunksize(victim);
    // 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。
    if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {
        remainder_size = size - nb;
        remainder      = chunk_at_offset(victim, nb);
        av-&gt;top        = remainder;
        // 这里设置 PREV_INUSE 是因为 top chunk 的 chunk 如果不是 fastbin，就必然会和
        // top chunk 合并，所以这里设置了 PREV_INUSE。
        set_head(victim, nb | PREV_INUSE |
                             (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
        set_head(remainder, remainder_size | PREV_INUSE);

        check_malloced_chunk(av, victim, nb);
        void *p = chunk2mem(victim);
        alloc_perturb(p, bytes);
        return p;
    }
    // 否则，判断是否有 fast chunk
    /* When we are using atomic ops to free fast chunks we can get
       here for all block sizes.  */
    else if (have_fastchunks(av)) {
        // 先执行一次fast bin的合并
        malloc_consolidate(av);
        /* restore original bin index */
        // 判断需要的chunk是在small bin范围内还是large bin范围内
        // 并计算对应的索引
        // 等待下次再看看是否可以
        if (in_smallbin_range(nb))
            idx = smallbin_index(nb);
        else
            idx = largebin_index(nb);
    }

    /*
       Otherwise, relay to handle system-dependent cases
     */
    // 否则的话，我们就只能从系统中再次申请一点内存了。
    else {
        void *p = sysmalloc(nb, av);
        if (p != NULL) alloc_perturb(p, bytes);
        return p;
    }
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="libc-calloc">
<h3>_libc_calloc<a class="headerlink" href="#libc-calloc" title="永久链接至标题">¶</a></h3>
<p>calloc 也是 libc 中的一种申请内存块的函数。在 <code class="docutils literal"><span class="pre">libc</span></code>中的包装为 <code class="docutils literal"><span class="pre">_libc_calloc</span></code>，具体介绍如下</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
  <span class="n">calloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n_elements</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">element_size</span><span class="p">);</span>
  <span class="n">Returns</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">n_elements</span> <span class="o">*</span> <span class="n">element_size</span> <span class="nb">bytes</span><span class="p">,</span> <span class="k">with</span> <span class="nb">all</span> <span class="n">locations</span>
  <span class="nb">set</span> <span class="n">to</span> <span class="n">zero</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">void</span><span class="o">*</span>  <span class="n">__libc_calloc</span><span class="p">(</span><span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="sysmalloc">
<h3>sysmalloc<a class="headerlink" href="#sysmalloc" title="永久链接至标题">¶</a></h3>
<p>有时间的时候再分析。</p>
</div>
</div>
<div class="section" id="id8">
<h2>释放内存块<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<div class="section" id="libc-free">
<h3>__libc_free<a class="headerlink" href="#libc-free" title="永久链接至标题">¶</a></h3>
<p>类似于 malloc，free 函数也有一层封装，命名格式与 malloc 基本类似。代码如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>void __libc_free(void *mem) {
    mstate    ar_ptr;
    mchunkptr p; /* chunk corresponding to mem */
    // 判断是否有钩子函数 __free_hook
    void (*hook)(void *, const void *) = atomic_forced_read(__free_hook);
    if (__builtin_expect(hook != NULL, 0)) {
        (*hook)(mem, RETURN_ADDRESS(0));
        return;
    }
    // free NULL没有作用
    if (mem == 0) /* free(0) has no effect */
        return;
    // 将mem转换为chunk状态
    p = mem2chunk(mem);
    // 如果该块内存是mmap得到的
    if (chunk_is_mmapped(p)) /* release mmapped memory. */
    {
        /* See if the dynamic brk/mmap threshold needs adjusting.
       Dumped fake mmapped chunks do not affect the threshold.  */
        if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;
            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;
            !DUMPED_MAIN_ARENA_CHUNK(p)) {
            mp_.mmap_threshold = chunksize(p);
            mp_.trim_threshold = 2 * mp_.mmap_threshold;
            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, 2,
                       mp_.mmap_threshold, mp_.trim_threshold);
        }
        munmap_chunk(p);
        return;
    }
    // 根据chunk获得分配区的指针
    ar_ptr = arena_for_chunk(p);
    // 执行释放
    _int_free(ar_ptr, p, 0);
}
</pre></div>
</div>
</div>
<div class="section" id="int-free">
<h3>_int_free<a class="headerlink" href="#int-free" title="永久链接至标题">¶</a></h3>
<p>函数初始时刻定义了一系列的变量，并且得到了用户想要释放的 chunk 的大小</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">_int_free</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>      <span class="o">/*</span> <span class="n">its</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="n">mfastbinptr</span> <span class="o">*</span>   <span class="n">fb</span><span class="p">;</span>        <span class="o">/*</span> <span class="n">associated</span> <span class="n">fastbin</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>       <span class="n">nextchunk</span><span class="p">;</span> <span class="o">/*</span> <span class="nb">next</span> <span class="n">contiguous</span> <span class="n">chunk</span> <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">nextsize</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">its</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="nb">int</span>             <span class="n">nextinuse</span><span class="p">;</span> <span class="o">/*</span> <span class="n">true</span> <span class="k">if</span> <span class="n">nextchunk</span> <span class="ow">is</span> <span class="n">used</span> <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">prevsize</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">size</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">contiguous</span> <span class="n">chunk</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>       <span class="n">bck</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">misc</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">linking</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>       <span class="n">fwd</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">misc</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">linking</span> <span class="o">*/</span>

    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">errstr</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="nb">int</span>         <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="id9">
<h4>简单的检查<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Little security check which won&#39;t hurt performance: the
   allocator never wrapps around at the end of the address space.
   Therefore we can exclude some size values which might appear
   here by accident or by &quot;design&quot; from some intruder.  */
// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？
// 指针必须得对齐，2*SIZE_SZ 这个对齐得仔细想想
if (__builtin_expect((uintptr_t) p &gt; (uintptr_t) -size, 0) ||
    __builtin_expect(misaligned_chunk(p), 0)) {
    errstr = &quot;free(): invalid pointer&quot;;
errout:
    if (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);
    malloc_printerr(check_action, errstr, chunk2mem(p), av);
    return;
}
/* We know that each chunk is at least MINSIZE bytes in size or a
   multiple of MALLOC_ALIGNMENT.  */
// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍
if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) {
    errstr = &quot;free(): invalid size&quot;;
    goto errout;
}
// 检查该chunk是否处于使用状态，非调试状态下没有作用
check_inuse_chunk(av, p);
</pre></div>
</div>
<p>其中</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/* Check if m has acceptable alignment */

#define aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p)                                                    \
    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \
     MALLOC_ALIGN_MASK)
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h4>fast bin<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<p>如果上述检查都合格的话，判断当前的 bin 是不是在 fast bin 范围内，在的话就插入到 <strong>fastbin 头部</strong>，即成为对应 fastbin 链表的<strong>第一个 free chunk</strong>。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>    /*
      If eligible, place chunk on a fastbin so it can be found
      and used quickly in malloc.
    */

    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast())

#if TRIM_FASTBINS
        /*
      If TRIM_FASTBINS set, don&#39;t place chunks
      bordering top into fastbins
        */
       //默认 #define TRIM_FASTBINS 0，因此默认情况下下面的语句不会执行
       // 如果当前chunk是fast chunk，并且下一个chunk是top chunk，则不能插入
        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)
#endif
            ) {
        // 下一个chunk的大小不能小于两倍的SIZE_SZ,并且
        // 下一个chunk的大小不能大于system_mem， 一般为132k
        // 如果出现这样的情况，就报错。
        if (__builtin_expect(
                chunksize_nomask(chunk_at_offset(p, size)) &lt;= 2 * SIZE_SZ, 0) ||
            __builtin_expect(
                chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, 0)) {
            /* We might not have a lock at this point and concurrent
               modifications
               of system_mem might have let to a false positive.  Redo the test
               after getting the lock.  */
            if (have_lock || ({
                    assert(locked == 0);
                    __libc_lock_lock(av-&gt;mutex);
                    locked = 1;
                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= 2 * SIZE_SZ ||
                        chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;
                })) {
                errstr = &quot;free(): invalid next size (fast)&quot;;
                goto errout;
            }
            if (!have_lock) {
                __libc_lock_unlock(av-&gt;mutex);
                locked = 0;
            }
        }
        // 将chunk的mem部分全部设置为perturb_byte
        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);
        // 设置fast chunk的标记位
        set_fastchunks(av);
        // 根据大小获取fast bin的索引
        unsigned int idx = fastbin_index(size);
        // 获取对应fastbin的头指针，被初始化后为NULL。
        fb               = &amp;fastbin(av, idx);

        /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */
        // 使用原子操作将P插入到链表中
        mchunkptr    old     = *fb, old2;
        unsigned int old_idx = ~0u;
        do {
            /* Check that the top of the bin is not the record we are going to
               add
               (i.e., double free).  */
            // so we can not double free one fastbin chunk
            // 防止对 fast bin double free
            if (__builtin_expect(old == p, 0)) {
                errstr = &quot;double free or corruption (fasttop)&quot;;
                goto errout;
            }
            /* Check that size of fastbin chunk at the top is the same as
               size of the chunk that we are adding.  We can dereference OLD
               only if we have the lock, otherwise it might have already been
               deallocated.  See use of OLD_IDX below for the actual check.  */
            if (have_lock &amp;&amp; old != NULL)
                old_idx = fastbin_index(chunksize(old));
            p-&gt;fd = old2 = old;
        } while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) !=
                 old2);
        // 确保fast bin的加入前与加入后相同
        if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect(old_idx != idx, 0)) {
            errstr = &quot;invalid fastbin entry (free)&quot;;
            goto errout;
        }
    }
</pre></div>
</div>
</div>
<div class="section" id="mmap-chunk">
<h4>合并非 mmap 的空闲 chunk<a class="headerlink" href="#mmap-chunk" title="永久链接至标题">¶</a></h4>
<p><strong>只有不是 fast bin 的情况下才会触发unlink</strong></p>
<p>首先我们先说一下为什么会合并chunk，这是为了避免heap中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p>
<ul class="simple">
<li>先考虑物理低地址空闲块</li>
<li>后考虑物理高地址空闲块</li>
</ul>
<p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong></p>
<p>在没有锁的情况下，先获得锁。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
  Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {
    if (!have_lock) {
        __libc_lock_lock(av-&gt;mutex);
        locked = 1;
    }
    nextchunk = chunk_at_offset(p, size);
</pre></div>
</div>
<div class="section" id="id11">
<h5>轻量级的检测<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Lightweight tests: check whether the block is already the
   top block.  */
// 当前free的chunk不能是top chunk
if (__glibc_unlikely(p == av-&gt;top)) {
    errstr = &quot;double free or corruption (top)&quot;;
    goto errout;
}
// 当前free的chunk的下一个chunk不能超过arena的边界
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect(contiguous(av) &amp;&amp;
                         (char *) nextchunk &gt;=
                             ((char *) av-&gt;top + chunksize(av-&gt;top)),
                     0)) {
    errstr = &quot;double free or corruption (out)&quot;;
    goto errout;
}
// 当前要free的chunk的使用标记没有被标记，double free
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely(!prev_inuse(nextchunk))) {
    errstr = &quot;double free or corruption (!prev)&quot;;
    goto errout;
}
// 下一个chunk的大小
nextsize = chunksize(nextchunk);
// next chunk size valid check
// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者
// nextsize是否大于系统可提供的内存
if (__builtin_expect(chunksize_nomask(nextchunk) &lt;= 2 * SIZE_SZ, 0) ||
    __builtin_expect(nextsize &gt;= av-&gt;system_mem, 0)) {
    errstr = &quot;free(): invalid next size (normal)&quot;;
    goto errout;
}
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h5>释放填充<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">将指针的mem部分全部设置为perturb_byte</span>
<span class="n">free_perturb</span><span class="p">(</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h5>后向合并-合并低地址 chunk<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* consolidate backward */
if (!prev_inuse(p)) {
    prevsize = prev_size(p);
    size += prevsize;
    p = chunk_at_offset(p, -((long) prevsize));
    unlink(av, p, bck, fwd);
}
</pre></div>
</div>
</div>
<div class="section" id="top-chunk-chunk">
<h5>下一块不是top chunk-前向合并-合并高地址chunk<a class="headerlink" href="#top-chunk-chunk" title="永久链接至标题">¶</a></h5>
<p>需要注意的是，如果下一块不是 top chunk 后，则合并高地址的 chunk ，并将合并后的 chunk 放入到unsorted bin中。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>// 如果下一个chunk不是top chunk
if (nextchunk != av-&gt;top) {
    /* get and clear inuse bit */
    // 获取下一个 chunk 的使用状态
    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
    // 如果不在使用，合并，否则清空当前chunk的使用状态。
    /* consolidate forward */
    if (!nextinuse) {
        unlink(av, nextchunk, bck, fwd);
        size += nextsize;
    } else
        clear_inuse_bit_at_offset(nextchunk, 0);

    /*
  Place the chunk in unsorted chunk list. Chunks are
  not placed into regular bins until after they have
  been given one chance to be used in malloc.
    */
    // 把 chunk 放在 unsorted chunk 链表的头部
    bck = unsorted_chunks(av);
    fwd = bck-&gt;fd;
    // 简单的检查
    if (__glibc_unlikely(fwd-&gt;bk != bck)) {
        errstr = &quot;free(): corrupted unsorted chunks&quot;;
        goto errout;
    }
    p-&gt;fd = fwd;
    p-&gt;bk = bck;
    // 如果是 large chunk，那就设置nextsize指针字段为NULL。
    if (!in_smallbin_range(size)) {
        p-&gt;fd_nextsize = NULL;
        p-&gt;bk_nextsize = NULL;
    }
    bck-&gt;fd = p;
    fwd-&gt;bk = p;

    set_head(p, size | PREV_INUSE);
    set_foot(p, size);

    check_free_chunk(av, p);
}
</pre></div>
</div>
</div>
<div class="section" id="top-chunk-top-chunk">
<h5>下一块是top chunk-合并到top chunk<a class="headerlink" href="#top-chunk-top-chunk" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
  If the chunk borders the current high end of memory,
  consolidate into top
*/
// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk
else {
    size += nextsize;
    set_head(p, size | PREV_INUSE);
    av-&gt;top = p;
    check_chunk(av, p);
}
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h5>向系统返还内存<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>        /*
          If freeing a large space, consolidate possibly-surrounding
          chunks. Then, if the total unused topmost memory exceeds trim
          threshold, ask malloc_trim to reduce top.

          Unless max_fast is 0, we don&#39;t know if there are fastbins
          bordering top, so we cannot tell for sure whether threshold
          has been reached unless fastbins are consolidated.  But we
          don&#39;t want to consolidate on each free.  As a compromise,
          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
          is reached.
        */
         // 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD
         // 一般合并到 top chunk 都会执行这部分代码。
         // 那就向系统返还内存
        if ((unsigned long) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) {
            // 如果有 fast chunk 就进行合并
            if (have_fastchunks(av)) malloc_consolidate(av);
            // 主分配区
            if (av == &amp;main_arena) {
##ifndef MORECORE_CANNOT_TRIM
                // top chunk 大于当前的收缩阙值
                if ((unsigned long) (chunksize(av-&gt;top)) &gt;=
                    (unsigned long) (mp_.trim_threshold))
                    systrim(mp_.top_pad, av);
##endif      // 非主分配区，则直接收缩heap
            } else {
                /* Always try heap_trim(), even if the top chunk is not
                   large, because the corresponding heap might go away.  */
                heap_info *heap = heap_for_ptr(top(av));

                assert(heap-&gt;ar_ptr == av);
                heap_trim(heap, mp_.top_pad);
            }
        }

        if (!have_lock) {
            assert(locked);
            __libc_lock_unlock(av-&gt;mutex);
        }
</pre></div>
</div>
</div>
</div>
<div class="section" id="mmapchunk">
<h4>释放mmap的chunk<a class="headerlink" href="#mmapchunk" title="永久链接至标题">¶</a></h4>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">//</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">chunk</span> <span class="n">was</span> <span class="n">allocated</span> <span class="n">via</span> <span class="n">mmap</span><span class="p">,</span> <span class="n">release</span> <span class="n">via</span> <span class="n">munmap</span><span class="p">()</span><span class="o">.</span>
    <span class="n">munmap_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="systrim">
<h3>systrim<a class="headerlink" href="#systrim" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="heap-trim">
<h3>heap_trim<a class="headerlink" href="#heap-trim" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="munmap-chunk">
<h3>munmap_chunk<a class="headerlink" href="#munmap-chunk" title="永久链接至标题">¶</a></h3>
</div>
</div>
<div class="section" id="id15">
<h2>删除堆<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="malloc-state">
<h2>malloc_state 相关函数<a class="headerlink" href="#malloc-state" title="永久链接至标题">¶</a></h2>
<div class="section" id="malloc-init-state">
<h3>malloc_init_state<a class="headerlink" href="#malloc-init-state" title="永久链接至标题">¶</a></h3>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Initialize</span> <span class="n">a</span> <span class="n">malloc_state</span> <span class="n">struct</span><span class="o">.</span>
   <span class="n">This</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">only</span> <span class="kn">from</span> <span class="nn">within</span> <span class="n">malloc_consolidate</span><span class="p">,</span> <span class="n">which</span> <span class="n">needs</span>
   <span class="n">be</span> <span class="n">called</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">same</span> <span class="n">contexts</span> <span class="n">anyway</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">never</span> <span class="n">called</span> <span class="n">directly</span>
   <span class="n">outside</span> <span class="n">of</span> <span class="n">malloc_consolidate</span> <span class="n">because</span> <span class="n">some</span> <span class="n">optimizing</span> <span class="n">compilers</span> <span class="k">try</span>
   <span class="n">to</span> <span class="n">inline</span> <span class="n">it</span> <span class="n">at</span> <span class="nb">all</span> <span class="n">call</span> <span class="n">points</span><span class="p">,</span> <span class="n">which</span> <span class="n">turns</span> <span class="n">out</span> <span class="ow">not</span> <span class="n">to</span> <span class="n">be</span> <span class="n">an</span>
   <span class="n">optimization</span> <span class="n">at</span> <span class="nb">all</span><span class="o">.</span> <span class="p">(</span><span class="n">Inlining</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">malloc_consolidate</span> <span class="ow">is</span> <span class="n">fine</span> <span class="n">though</span><span class="o">.</span><span class="p">)</span>
 <span class="o">*/</span>

<span class="n">static</span> <span class="n">void</span> <span class="n">malloc_init_state</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span>     <span class="n">i</span><span class="p">;</span>
    <span class="n">mbinptr</span> <span class="nb">bin</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Establish</span> <span class="n">circular</span> <span class="n">links</span> <span class="k">for</span> <span class="n">normal</span> <span class="n">bins</span> <span class="o">*/</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBINS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">bin</span>     <span class="o">=</span> <span class="n">bin_at</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="nb">bin</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">;</span>
    <span class="p">}</span>

<span class="c1">#if MORECORE_CONTIGUOUS</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
<span class="c1">#endif</span>
        <span class="n">set_noncontiguous</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="n">set_max_fast</span><span class="p">(</span><span class="n">DEFAULT_MXFAST</span><span class="p">);</span>
    <span class="o">//</span> <span class="n">设置</span> <span class="n">flags</span> <span class="n">标记目前没有fast</span> <span class="n">chunk</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FASTCHUNKS_BIT</span><span class="p">;</span>
    <span class="o">//</span> <span class="n">就是</span> <span class="n">unsorted</span> <span class="nb">bin</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">initial_top</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="malloc-consolidate">
<h3>malloc_consolidate<a class="headerlink" href="#malloc-consolidate" title="永久链接至标题">¶</a></h3>
<p>该函数主要有两个功能</p>
<ol class="arabic simple">
<li>若 fastbin 未初始化，即 global_max_fast 为0，那就初始化 malloc_state。</li>
<li>如果已经初始化的话，就合并 fastbin 中的 chunk。</li>
</ol>
<p>基本的流程如下</p>
<div class="section" id="id16">
<h4>初始<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h4>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">malloc_consolidate</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mfastbinptr</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>             <span class="o">/*</span> <span class="n">current</span> <span class="n">fastbin</span> <span class="n">being</span> <span class="n">consolidated</span> <span class="o">*/</span>
    <span class="n">mfastbinptr</span> <span class="o">*</span><span class="n">maxfb</span><span class="p">;</span>          <span class="o">/*</span> <span class="n">last</span> <span class="n">fastbin</span> <span class="p">(</span><span class="k">for</span> <span class="n">loop</span> <span class="n">control</span><span class="p">)</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>    <span class="n">p</span><span class="p">;</span>              <span class="o">/*</span> <span class="n">current</span> <span class="n">chunk</span> <span class="n">being</span> <span class="n">consolidated</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>    <span class="n">nextp</span><span class="p">;</span>          <span class="o">/*</span> <span class="nb">next</span> <span class="n">chunk</span> <span class="n">to</span> <span class="n">consolidate</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>    <span class="n">unsorted_bin</span><span class="p">;</span>   <span class="o">/*</span> <span class="nb">bin</span> <span class="n">header</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>    <span class="n">first_unsorted</span><span class="p">;</span> <span class="o">/*</span> <span class="n">chunk</span> <span class="n">to</span> <span class="n">link</span> <span class="n">to</span> <span class="o">*/</span>

    <span class="o">/*</span> <span class="n">These</span> <span class="n">have</span> <span class="n">same</span> <span class="n">use</span> <span class="k">as</span> <span class="ow">in</span> <span class="n">free</span><span class="p">()</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>       <span class="n">nextchunk</span><span class="p">;</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">nextsize</span><span class="p">;</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">prevsize</span><span class="p">;</span>
    <span class="nb">int</span>             <span class="n">nextinuse</span><span class="p">;</span>
    <span class="n">mchunkptr</span>       <span class="n">bck</span><span class="p">;</span>
    <span class="n">mchunkptr</span>       <span class="n">fwd</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h4>合并 chunk<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h4>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/*
  If max_fast is 0, we know that av hasn&#39;t
  yet been initialized, in which case do so below
*/
// 说明 fastbin 已经初始化
if (get_max_fast() != 0) {
    // 清空 fastbin 标记
    // 因为要合并 fastbin 中的 chunk 了。
    clear_fastchunks(av);
    //
    unsorted_bin = unsorted_chunks(av);

    /*
      Remove each chunk from fast bin and consolidate it, placing it
      then in unsorted bin. Among other reasons for doing this,
      placing in unsorted bin avoids needing to calculate actual bins
      until malloc is sure that chunks aren&#39;t immediately going to be
      reused anyway.
    */
    // 按照 fd 顺序遍历 fastbin 的每一个 bin，将 bin 中的每一个 chunk 合并掉。
    maxfb = &amp;fastbin(av, NFASTBINS - 1);
    fb    = &amp;fastbin(av, 0);
    do {
        p = atomic_exchange_acq(fb, NULL);
        if (p != 0) {
            do {
                check_inuse_chunk(av, p);
                nextp = p-&gt;fd;

                /* Slightly streamlined version of consolidation code in
                 * free() */
                size      = chunksize(p);
                nextchunk = chunk_at_offset(p, size);
                nextsize  = chunksize(nextchunk);

                if (!prev_inuse(p)) {
                    prevsize = prev_size(p);
                    size += prevsize;
                    p = chunk_at_offset(p, -((long) prevsize));
                    unlink(av, p, bck, fwd);
                }

                if (nextchunk != av-&gt;top) {
                    // 判断 nextchunk 是否是空闲的。
                    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);

                    if (!nextinuse) {
                        size += nextsize;
                        unlink(av, nextchunk, bck, fwd);
                    } else
                     // 设置 nextchunk 的 prev inuse 为0，以表明可以合并当前 fast chunk。
                        clear_inuse_bit_at_offset(nextchunk, 0);

                    first_unsorted     = unsorted_bin-&gt;fd;
                    unsorted_bin-&gt;fd   = p;
                    first_unsorted-&gt;bk = p;

                    if (!in_smallbin_range(size)) {
                        p-&gt;fd_nextsize = NULL;
                        p-&gt;bk_nextsize = NULL;
                    }

                    set_head(p, size | PREV_INUSE);
                    p-&gt;bk = unsorted_bin;
                    p-&gt;fd = first_unsorted;
                    set_foot(p, size);
                }

                else {
                    size += nextsize;
                    set_head(p, size | PREV_INUSE);
                    av-&gt;top = p;
                }

            } while ((p = nextp) != 0);
        }
    } while (fb++ != maxfb);
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h4>初始化<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<p>说明 fastbin 还没有初始化。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>} else {
    malloc_init_state(av);
    // 在非调试情况下没有什么用，在调试情况下，做一些检测。
    check_malloc_state(av);
}
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id19">
<h2>测试支持<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<p>下面的代码用于支持测试，默认情况下 perturb_byte 是0。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="nb">int</span> <span class="n">perturb_byte</span><span class="p">;</span>

<span class="n">static</span> <span class="n">void</span> <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">perturb_byte</span><span class="p">))</span> <span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">perturb_byte</span> <span class="o">^</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">static</span> <span class="n">void</span> <span class="n">free_perturb</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">perturb_byte</span><span class="p">))</span> <span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">perturb_byte</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<div class="sphinx-toc sphinxglobaltoc">
<h3><a href="../../index.html">內容目录</a></h3>
<p class="caption"><span class="caption-text">CTF 介绍</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/history.html">CTF 竞赛的历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/mode.html">CTF 竞赛模式简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/content.html">CTF 竞赛内容</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/experience.html">线下攻防经验小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/cgc.html">CGC 网络超级挑战赛</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/resources.html">学习资源</a></li>
</ul>
<p class="caption"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../misc/about.html">杂项简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/recon.html">信息搜集技术</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/encode/index.html">编码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/prefix.html">取证隐写</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/picture/index.html">图片分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/traffic/index.html">流量包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/archive/index.html">压缩包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/audio/index.html">音频分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/disk_memory/index.html">磁盘 / 内存分析</a></li>
</ul>
<p class="caption"><span class="caption-text">Crypto</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/introduction.html">密码学简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/classical/index.html">古典密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/symmetric/index.html">对称加密</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/asymmetric/index.html">非对称密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/hash/index.html">哈希函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/signature/index.html">数字签名</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/others/others.html">证书格式</a></li>
</ul>
<p class="caption"><span class="caption-text">Web</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../web/index.html">WEB 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/sqli.html">SQL 注入</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/xss.html">XSS 跨站脚本攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/csrf.html">CSRF 跨站请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/ssrf.html">SSRF 服务端请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/php.html">PHP 代码审计</a></li>
</ul>
<p class="caption"><span class="caption-text">Reverse</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/introduction.html">软件逆向工程简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/unpack/index.html">Unpack Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/unicorn/index.html">Unicorn Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/anti_debug/index.html">Anti Debug Tech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/linux/index.html">Linux RE</a></li>
</ul>
<p class="caption"><span class="caption-text">Pwn</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../stackoverflow/index.html">栈溢出</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fmtstr/index.html">格式化字符串漏洞</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">堆利用</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="heap_overview.html">堆概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="heap_structure.html">堆相关数据结构</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">深入理解堆的实现</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">堆实现概览</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">堆初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">创建堆</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">双向链表相关操作</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unlink">unlink</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">申请内存块</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#libc-malloc">__libc_malloc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#int-malloc">_int_malloc</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#arena">arena</a></li>
<li class="toctree-l5"><a class="reference internal" href="#fast-bin">fast bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="#small-bin">small bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="#large-bin">large bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id7">大循环</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#unsort-bin">unsort bin 遍历</a></li>
<li class="toctree-l6"><a class="reference internal" href="#large-chunk">large chunk</a></li>
<li class="toctree-l6"><a class="reference internal" href="#chunk">寻找较大 chunk</a></li>
<li class="toctree-l6"><a class="reference internal" href="#top-chunk">使用 top chunk</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#libc-calloc">_libc_calloc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sysmalloc">sysmalloc</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id8">释放内存块</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#libc-free">__libc_free</a></li>
<li class="toctree-l4"><a class="reference internal" href="#int-free">_int_free</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id9">简单的检查</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id10">fast bin</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mmap-chunk">合并非 mmap 的空闲 chunk</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#id11">轻量级的检测</a></li>
<li class="toctree-l6"><a class="reference internal" href="#id12">释放填充</a></li>
<li class="toctree-l6"><a class="reference internal" href="#id13">后向合并-合并低地址 chunk</a></li>
<li class="toctree-l6"><a class="reference internal" href="#top-chunk-chunk">下一块不是top chunk-前向合并-合并高地址chunk</a></li>
<li class="toctree-l6"><a class="reference internal" href="#top-chunk-top-chunk">下一块是top chunk-合并到top chunk</a></li>
<li class="toctree-l6"><a class="reference internal" href="#id14">向系统返还内存</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#mmapchunk">释放mmap的chunk</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#systrim">systrim</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-trim">heap_trim</a></li>
<li class="toctree-l4"><a class="reference internal" href="#munmap-chunk">munmap_chunk</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id15">删除堆</a></li>
<li class="toctree-l3"><a class="reference internal" href="#malloc-state">malloc_state 相关函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#malloc-init-state">malloc_init_state</a></li>
<li class="toctree-l4"><a class="reference internal" href="#malloc-consolidate">malloc_consolidate</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id16">初始</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id17">合并 chunk</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id18">初始化</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id19">测试支持</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="heapoverflow_basic.html">堆溢出</a></li>
<li class="toctree-l2"><a class="reference internal" href="off_by_one.html">堆中的 Off-By-One</a></li>
<li class="toctree-l2"><a class="reference internal" href="unlink.html">Unlink</a></li>
<li class="toctree-l2"><a class="reference internal" href="use_after_free.html">Use After Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="fastbin_attack.html">Fastbin Attack</a></li>
<li class="toctree-l2"><a class="reference internal" href="chunk_extend_shrink.html">Chunk Extend/Shrink</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_einherjar.html">House Of Einherjar</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_lore.html">House of Lore</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_force.html">House Of Force</a></li>
<li class="toctree-l2"><a class="reference internal" href="unsorted_bin_attack.html">Unsorted Bin Attack</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Executable</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../executable/elf/index.html">ELF文件</a></li>
</ul>
</div>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../index.html" title="內容目录"
             >toc</a></li>
        <li class="right" >
          <a href="heapoverflow_basic.html" title="堆溢出"
             >下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="heap_structure.html" title="堆相关数据结构"
             >上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">CTF Wiki </a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >堆利用</a> &#187;</li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2017, CTF Wiki.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7 创建。
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>