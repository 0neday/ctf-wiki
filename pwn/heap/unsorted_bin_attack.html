


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Unsorted Bin Attack &#8212; CTF Wiki </title>
    <link rel="stylesheet" href="../../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../_static/cloud.base.js"></script>
    <script type="text/javascript" src="../../_static/cloud.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="ELF文件" href="../../executable/elf/index.html" />
    <link rel="prev" title="House Of Force" href="house_of_force.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../index.html" title="內容目录"
             accesskey="C">toc</a></li>
        <li class="right" >
          <a href="../../executable/elf/index.html" title="ELF文件"
             accesskey="N">下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="house_of_force.html" title="House Of Force"
             accesskey="P">上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">CTF Wiki </a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">堆利用</a> &#187;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="unsorted-bin-attack">
<h1>Unsorted Bin Attack<a class="headerlink" href="#unsorted-bin-attack" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>概述<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。</p>
<p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p>
<p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p>
</div>
<div class="section" id="unsorted-bin">
<h2>Unsorted Bin 回顾<a class="headerlink" href="#unsorted-bin" title="永久链接至标题">¶</a></h2>
<p>在介绍 Unsorted Bin 攻击前，可以先回顾一下 Unsorted Bin 的基本来源以及基本使用情况。</p>
<div class="section" id="id2">
<h3>基本来源<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于top chunk的解释，请参考下面的介绍。</li>
<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li>
</ol>
</div>
<div class="section" id="id3">
<h3>基本使用情况<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk
分别插入到对应的 bin 中。</li>
</ol>
</div>
</div>
<div class="section" id="id4">
<h2>原理<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>这里我以 shellfish 的 how2heap 仓库中的 <a class="reference external" href="https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c">unsorted_bin_attack.c</a> 为例进行介绍，这里我做一些简单的修改，如下</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;This file demonstrates unsorted bin attack by write a large &quot;</span>
                  <span class="s2">&quot;unsigned long value into stack</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span>
      <span class="n">stderr</span><span class="p">,</span>
      <span class="s2">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span>
      <span class="s2">&quot;attacks, such as rewriting the &quot;</span>
      <span class="s2">&quot;global variable global_max_fast in libc for further fastbin attack</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">);</span>

  <span class="n">unsigned</span> <span class="n">long</span> <span class="n">target_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
          <span class="s2">&quot;Let&#39;s first look at the target we want to rewrite on stack:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;%p: </span><span class="si">%ld</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_var</span><span class="p">,</span> <span class="n">target_var</span><span class="p">);</span>

  <span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Now, we allocate first normal chunk on the heap at: %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="n">p</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;And allocate another normal chunk in order to avoid &quot;</span>
                  <span class="s2">&quot;consolidating the top chunk with&quot;</span>
                  <span class="s2">&quot;the first one during the free()</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">malloc</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;We free the first chunk now and it will be inserted in the &quot;</span>
                  <span class="s2">&quot;unsorted bin with its bk pointer &quot;</span>
                  <span class="s2">&quot;point to %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="o">/*------------</span><span class="n">VULNERABILITY</span><span class="o">-----------*/</span>

  <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">target_var</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Now emulating a vulnerability that can overwrite the &quot;</span>
                  <span class="s2">&quot;victim-&gt;bk pointer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;And we write it with the target address-16 (in 32-bits &quot;</span>
                  <span class="s2">&quot;machine, it should be target address-8):%p</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span>
          <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="o">//------------------------------------</span>

  <span class="n">malloc</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Let&#39;s malloc again to get the chunk we just free. During &quot;</span>
                  <span class="s2">&quot;this time, target should has already been &quot;</span>
                  <span class="s2">&quot;rewrite:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;%p: %p</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target_var</span><span class="p">,</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="p">)</span><span class="n">target_var</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>程序执行后的效果为</p>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>➜  unsorted_bin_attack git:(master) ✗ gcc unsorted_bin_attack.c -o unsorted_bin_attack
➜  unsorted_bin_attack git:(master) ✗ ./unsorted_bin_attack
This file demonstrates unsorted bin attack by write a large unsigned long value into stack
In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack

Let&#39;s first look at the target we want to rewrite on stack:
0x7ffe0d232518: 0

Now, we allocate first normal chunk on the heap at: 0x1fce010
And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()

We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78
Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer
And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508

Let&#39;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:
0x7ffe0d232518: 0x7f1c705ffb78
</pre></div>
</div>
<p>这里我们可以使用一个图来描述一下具体发生的流程以及背后的原理。</p>
<p><img alt="image0" src="../../_images/unsorted_bin_attack_order.png" /></p>
<p><strong>初始状态时</strong></p>
<p>unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。</p>
<p><strong>执行free(p)</strong></p>
<p>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p>
<p><strong>修改p[1]</strong></p>
<p>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p>
<p><strong>申请400大小的chunk</strong></p>
<p>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去unsorted bin中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>while ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) {
    bck = victim-&gt;bk;
    if (__builtin_expect(chunksize_nomask(victim) &lt;= 2 * SIZE_SZ, 0) ||
        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, 0))
        malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,
                        chunk2mem(victim), av);
    size = chunksize(victim);

    /*
       If a small request, try to use last remainder if it is the
       only chunk in unsorted bin.  This helps promote locality for
       runs of consecutive small requests. This is the only
       exception to best-fit, and applies only when there is
       no exact fit for a small chunk.
     */
    /* 显然，bck被修改，并不符合这里的要求*/
    if (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;
        victim == av-&gt;last_remainder &amp;&amp;
        (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) {
        ....
    }

    /* remove from unsorted list */
    unsorted_chunks(av)-&gt;bk = bck;
    bck-&gt;fd                 = unsorted_chunks(av);
</pre></div>
</div>
<ul class="simple">
<li>victim = unsorted_chunks(av)-&gt;bk=p</li>
<li>bck = victim-&gt;bk=p-&gt;bk = target addr-16</li>
<li>unsorted_chunks(av)-&gt;bk = bck=target addr-16</li>
<li>bck-&gt;fd = *(target addr -16+16) = unsorted_chunks(av);</li>
</ul>
<p><strong>可以看出，在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。</strong>然而，需要注意的是，unsorted bin
链表可能就此破坏，在插入 chunk 时，可能会出现问题。</p>
<p>即修改 target 处的值为 unsorted bin 的链表头部 0x7f1c705ffb78，也就是之前输出的信息。</p>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span><span class="n">We</span> <span class="n">free</span> <span class="n">the</span> <span class="n">first</span> <span class="n">chunk</span> <span class="n">now</span> <span class="ow">and</span> <span class="n">it</span> <span class="n">will</span> <span class="n">be</span> <span class="n">inserted</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">unsorted</span> <span class="nb">bin</span> <span class="k">with</span> <span class="n">its</span> <span class="n">bk</span> <span class="n">pointer</span> <span class="n">point</span> <span class="n">to</span> <span class="mh">0x7f1c705ffb78</span>
<span class="n">Now</span> <span class="n">emulating</span> <span class="n">a</span> <span class="n">vulnerability</span> <span class="n">that</span> <span class="n">can</span> <span class="n">overwrite</span> <span class="n">the</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="n">pointer</span>
<span class="n">And</span> <span class="n">we</span> <span class="n">write</span> <span class="n">it</span> <span class="k">with</span> <span class="n">the</span> <span class="n">target</span> <span class="n">address</span><span class="o">-</span><span class="mi">16</span> <span class="p">(</span><span class="ow">in</span> <span class="mi">32</span><span class="o">-</span><span class="n">bits</span> <span class="n">machine</span><span class="p">,</span> <span class="n">it</span> <span class="n">should</span> <span class="n">be</span> <span class="n">target</span> <span class="n">address</span><span class="o">-</span><span class="mi">8</span><span class="p">):</span><span class="mh">0x7ffe0d232508</span>

<span class="n">Let</span><span class="s1">&#39;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:</span>
<span class="mh">0x7ffe0d232518</span><span class="p">:</span> <span class="mh">0x7f1c705ffb78</span>
</pre></div>
</div>
<p>这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。<strong>而且，需要注意的是，</strong></p>
<p>这看起来似乎并没有什么用处，但是其实还是有点卵用的，比如说</p>
<ul class="simple">
<li>我们通过修改循环的次数来使得程序可以执行多次循环。</li>
<li>我们可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack了。</li>
</ul>
</div>
<div class="section" id="hitcon-training-lab14-magic-heap">
<h2>HITCON Training lab14 magic heap<a class="headerlink" href="#hitcon-training-lab14-magic-heap" title="永久链接至标题">¶</a></h2>
<p>这里我们修改一下源程序中的 l33t 函数，以便于可以正常运行。</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">l33t</span><span class="p">()</span> <span class="p">{</span> <span class="n">system</span><span class="p">(</span><span class="s2">&quot;cat ./flag&quot;</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id5">
<h3>基本信息<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span>➜  hitcontraining_lab14 git:(master) file magicheap
magicheap: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=9f84548d48f7baa37b9217796c2ced6e6281bb6f, not stripped
➜  hitcontraining_lab14 git:(master) checksec magicheap
[*] &#39;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/hitcontraining_lab14/magicheap&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</pre></div>
</div>
<p>可以看出，该程序是一个动态链接的64程序，主要开启了 NX 保护与 Canary 保护。</p>
</div>
<div class="section" id="id6">
<h3>基本功能<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>程序大概就是自己写的堆管理器，主要有以下功能</p>
<ol class="arabic simple">
<li>创建堆。根据用户指定大小申请相应堆，并且读入指定长度的内容，但是并没有设置 NULL。</li>
<li>编辑堆。根据指定的索引判断对应堆是不是非空，如果非空，就根据用户读入的大小，来修改堆的内容，这里其实就出现了任意长度堆溢出的漏洞。</li>
<li>删除堆。根据指定的索引判断对应堆是不是非空，如果非空，就将对应堆释放并置为 NULL。</li>
</ol>
<p>同时，我们看到，当我们控制 v3 为 4869，同时控制 magic 大于 4869，就可以得到 flag 了。</p>
</div>
<div class="section" id="id7">
<h3>利用<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>很显然， 我们直接利用 unsorted bin attack 即可。</p>
<ol class="arabic simple">
<li>释放一个堆块到 unsorted bin 中。</li>
<li>利用堆溢出漏洞修改 unsorted bin 中对应堆块的 bk 指针为 &amp;magic-16。</li>
<li>触发漏洞即可。</li>
</ol>
<p>代码如下</p>
</div>
</div>
<div class="section" id="ctf-zerostorage">
<h2>2016 0CTF zerostorage<a class="headerlink" href="#ctf-zerostorage" title="永久链接至标题">¶</a></h2>
<p><strong>注：待进一步完成。</strong></p>
<p>这里我们以 2016 年 0CTF 的zerostorage为例，进行介绍。</p>
<p><strong>这个题当时给了服务器的系统版本和内核版本，所以自己可以下一个一模一样的进行调试，这里我们就直接用自己的本地机器调试了。但是在目前的Ubuntu 16.04
中，由于进一步的随机化，导致libc加载的位置与程序模块加载的位置之间的相对偏移不再固定，所以 BrieflyX 的策略就无法再次使用，似乎只能用 angelboy 的策略了。</strong></p>
<p>参考文章</p>
<ul class="simple">
<li><a class="reference external" href="http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/">http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/</a></li>
<li><a class="reference external" href="https://github.com/HQ1995/Heap_Senior_Driver/tree/master/0ctf2016/zerostorage">https://github.com/HQ1995/Heap_Senior_Driver/tree/master/0ctf2016/zerostorage</a></li>
<li><a class="reference external" href="https://github.com/scwuaptx/CTF/blob/master/2016-writeup/0ctf/zerostorage.py">https://github.com/scwuaptx/CTF/blob/master/2016-writeup/0ctf/zerostorage.py</a></li>
</ul>
<div class="section" id="id8">
<h3>安全性检查<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>可以看出，该程序开启了所有的保护</p>
<div class="code shell highlight-default"><div class="highlight"><pre><span></span><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">checksec</span>
<span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="s1">&#39;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/zerostorage/zerostorage&#39;</span>
    <span class="n">Arch</span><span class="p">:</span>     <span class="n">amd64</span><span class="o">-</span><span class="mi">64</span><span class="o">-</span><span class="n">little</span>
    <span class="n">RELRO</span><span class="p">:</span>    <span class="n">Full</span> <span class="n">RELRO</span>
    <span class="n">Stack</span><span class="p">:</span>    <span class="n">Canary</span> <span class="n">found</span>
    <span class="n">NX</span><span class="p">:</span>       <span class="n">NX</span> <span class="n">enabled</span>
    <span class="n">PIE</span><span class="p">:</span>      <span class="n">PIE</span> <span class="n">enabled</span>
    <span class="n">FORTIFY</span><span class="p">:</span>  <span class="n">Enabled</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>基本功能分析<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>程序管理在 bss 段的存储空间 storage ，具有插入，删除，合并，删除，查看，枚举，退出功能。这个storage的结构体如下</p>
<div class="code text highlight-default"><div class="highlight"><pre><span></span>00000000 Storage         struc ; (sizeof=0x18, mappedto_7)
00000000                                         ; XREF: .bss:storage_list/r
00000000 use             dq ?
00000008 size            dq ?
00000010 xor_addr        dq ?
00000018 Storage         ends
</pre></div>
</div>
<div class="section" id="insert-1">
<h4>insert-1<a class="headerlink" href="#insert-1" title="永久链接至标题">¶</a></h4>
<p>基本功能如下</p>
<ol class="arabic simple">
<li>逐一查看 storage 数组，查找第一个未使用的元素，但是这个数组最大也就是32。</li>
<li>读取storage 元素所需要存储内容的长度。<ul>
<li>如果长度不大于0，直接退出；</li>
<li>否则如果申请的字节数小于128，那就设置为128；</li>
<li>否则，如果申请的字节数不大于4096，那就设置为对应的数值；</li>
<li>否则，设置为4096。</li>
</ul>
</li>
<li>使用 calloc 分配指定长度，注意 calloc 会初始化 chunk 为0。</li>
<li>将 calloc 分配的内存地址与 bss 段的一个内存（初始时刻为一个随机数）进行抑或，得到一个新的内存地址。</li>
<li>根据读取的storage的大小来读入内容。</li>
<li>将对应的storage的大小以及存储内容的地址保存到对应的storage 元素中，并标记该元素处于可用状态。<strong>但是，需要注意的是，这里记录的storage的大小是自己输入的大小！！！</strong></li>
<li>递增 storage num的数量。</li>
</ol>
</div>
<div class="section" id="update-2">
<h4>update-2<a class="headerlink" href="#update-2" title="永久链接至标题">¶</a></h4>
<ol class="arabic simple">
<li>如果没有任何存储，就直接返回。</li>
<li>读入要更新的storage元素的id，如果id大于31或者目前处于不处于使用状态，说明不对，直接返回。</li>
<li>读取<strong>更新后</strong>storage 元素所需要存储内容的长度。<ul>
<li>如果长度不大于0，直接退出；</li>
<li>否则如果申请的字节数小于128，那就设置为128；</li>
<li>否则，如果申请的字节数不大于4096，那就设置为对应的数值；</li>
<li>否则，设置为4096。</li>
</ul>
</li>
<li>根据 bss 段对应的随机数获取原先storage 存储内容的地址，</li>
<li>如果更新后所需的长度不等于更新前的长度，就使用realloc为其重新分配内存。</li>
<li>再次读取数据，同时更新storage 元素。</li>
</ol>
</div>
<div class="section" id="merge-3">
<h4>merge-3<a class="headerlink" href="#merge-3" title="永久链接至标题">¶</a></h4>
<ol class="arabic simple">
<li>如果正在使用的元素不大于1个，那么无法合并，直接退出即可。</li>
<li>判断storage是否已经满了，如果不满，找出空闲的那一块。</li>
<li>分别读取merge_from的id以及merge_to的id号，并进行相应大小以及使用状态的检测。</li>
<li>根据最初用户输入的大小来计算两个 merge 到一起后所需要的空间，<strong>如果不大于128，那就不会申请新的空间</strong>，否则就申请相应大小的新的空间。</li>
<li>依次将merge_to与merge_from的内容拷贝到相对应的位置。</li>
<li><strong>最后存储merge_from内容的内存地址被释放了，但并没有被置为NULL。同时，存放merge_to内容的内存地址并没有被释放，相应的storage的抑或后的地址只是被置为了NULL。</strong></li>
</ol>
<p><strong>但是需要注意的是，，在merge的时候，并没有检测两个storage的ID是否相同。</strong></p>
</div>
<div class="section" id="delete-4">
<h4>delete-4<a class="headerlink" href="#delete-4" title="永久链接至标题">¶</a></h4>
<ol class="arabic simple">
<li>如果没有存储任何元素，那就直接返回。</li>
<li>读取指定要修改的storage的元素的id，如果 id 大于32，就直接返回。</li>
<li>如果 storage 的对应元素并不在使用状态，那么也同时返回。</li>
<li>之后就是将元素对应的字段分别设置为NULL，并且释放对应的内存。</li>
</ol>
</div>
<div class="section" id="view-5">
<h4>view-5<a class="headerlink" href="#view-5" title="永久链接至标题">¶</a></h4>
<ol class="arabic simple">
<li>如果没有存储任何元素，那就直接返回。</li>
<li>读取指定要修改的storage的元素的id，如果 id 大于32，就直接返回。</li>
<li>如果 storage 的对应元素并不在使用状态，那么也同时返回。</li>
<li>输入对应的storage 的内容。</li>
</ol>
</div>
<div class="section" id="list-6">
<h4>list-6<a class="headerlink" href="#list-6" title="永久链接至标题">¶</a></h4>
<ol class="arabic simple">
<li>如果没有存储任何元素，那就直接返回。</li>
<li>读取指定要修改的storage的元素的id，如果 id 大于32，就直接返回。</li>
<li>遍历所有正在使用的storage，输入其对应的下标以及对应storage的大小。</li>
</ol>
</div>
</div>
<div class="section" id="id10">
<h3>漏洞确定<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>通过这么简单的分析，我们可以 基本确定漏洞主要就是集中在insert操作与merge操作中，尤其是当我们merge两个较小size的storage时，会出现一些问题。</p>
<p>我们来具体分析一下，如果我们在insert过程中插入较小的size（比如8）的storage A，那么，当我们进行merge时，假设我们选择merge的两个storage
都为A，那么此时程序会直接把就会直接把A的内容再添加到A的原有内容的后面，然后接着就会把A对应的存储数据部分的内存free掉，但是这并没有什么作用，因为A存储内容的地址被赋给了另外一个storage，当再访问merge
后的 storage B部分的内容时，由于B的存储数据部分的地址其实就是A对应的存储数据的地址，所以打印的就是A的数据部分的内容。但是，我们之前刚刚把A对应的内存释放掉，而A由于不在fast
bin范围内，所以只会被放到unsorted bin中（而且此时只有一个），所以此时A的fd和bk都存放的是unsorted bin的一个基地址。</p>
<p>如果我们在merge之前曾经删除过一个storage C，那么在我们merge A后，A就会插在unsorted bin的双向链表的首部，所以其fd则是C对应的地址，bk则是unsorted bin的一个基地址。这样我们就可以直接泄露两个地址。</p>
<p>而且需要注意的是，我们还是可以去修改merge后的B的内容的，所以这其实就是个Use After Free。</p>
</div>
<div class="section" id="id11">
<h3>利用流程<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>。。。。</p>
</div>
</div>
<div class="section" id="id12">
<h2>题目<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="转向" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<div class="sphinx-toc sphinxglobaltoc">
<h3><a href="../../index.html">內容目录</a></h3>
<p class="caption"><span class="caption-text">CTF 介绍</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/history.html">CTF 竞赛的历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/mode.html">CTF 竞赛模式简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/content.html">CTF 竞赛内容</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/experience.html">线下攻防经验小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/cgc.html">CGC 网络超级挑战赛</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/resources.html">学习资源</a></li>
</ul>
<p class="caption"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../misc/about.html">杂项简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/recon.html">信息搜集技术</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/encode/index.html">编码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/prefix.html">取证隐写</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/picture/index.html">图片分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/traffic/index.html">流量包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/archive/index.html">压缩包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/audio/index.html">音频分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/disk_memory/index.html">磁盘 / 内存分析</a></li>
</ul>
<p class="caption"><span class="caption-text">Crypto</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/introduction.html">密码学简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/classical/index.html">古典密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/symmetric/index.html">对称加密</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/asymmetric/index.html">非对称密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/hash/index.html">哈希函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/signature/index.html">数字签名</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/others/others.html">证书格式</a></li>
</ul>
<p class="caption"><span class="caption-text">Web</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../web/index.html">WEB 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/sqli.html">SQL 注入</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/xss.html">XSS 跨站脚本攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/csrf.html">CSRF 跨站请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/ssrf.html">SSRF 服务端请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/php.html">PHP 代码审计</a></li>
</ul>
<p class="caption"><span class="caption-text">Reverse</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/introduction.html">软件逆向工程简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/unpack/index.html">Unpack Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/unicorn/index.html">Unicorn Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/anti_debug/index.html">Anti Debug Tech</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/linux/index.html">Linux RE</a></li>
</ul>
<p class="caption"><span class="caption-text">Pwn</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../stackoverflow/index.html">栈溢出</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fmtstr/index.html">格式化字符串漏洞</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">堆利用</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="heap_overview.html">堆概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="heap_structure.html">堆相关数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="heap_implementation_details.html">深入理解堆的实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="heapoverflow_basic.html">堆溢出</a></li>
<li class="toctree-l2"><a class="reference internal" href="off_by_one.html">堆中的 Off-By-One</a></li>
<li class="toctree-l2"><a class="reference internal" href="unlink.html">Unlink</a></li>
<li class="toctree-l2"><a class="reference internal" href="use_after_free.html">Use After Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="fastbin_attack.html">Fastbin Attack</a></li>
<li class="toctree-l2"><a class="reference internal" href="chunk_extend_shrink.html">Chunk Extend/Shrink</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_einherjar.html">House Of Einherjar</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_lore.html">House of Lore</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_force.html">House Of Force</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Unsorted Bin Attack</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unsorted-bin">Unsorted Bin 回顾</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">基本来源</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">基本使用情况</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hitcon-training-lab14-magic-heap">HITCON Training lab14 magic heap</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">基本信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">基本功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">利用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ctf-zerostorage">2016 0CTF zerostorage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">安全性检查</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">基本功能分析</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#insert-1">insert-1</a></li>
<li class="toctree-l5"><a class="reference internal" href="#update-2">update-2</a></li>
<li class="toctree-l5"><a class="reference internal" href="#merge-3">merge-3</a></li>
<li class="toctree-l5"><a class="reference internal" href="#delete-4">delete-4</a></li>
<li class="toctree-l5"><a class="reference internal" href="#view-5">view-5</a></li>
<li class="toctree-l5"><a class="reference internal" href="#list-6">list-6</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id10">漏洞确定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">利用流程</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">题目</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Executable</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../executable/elf/index.html">ELF文件</a></li>
</ul>
</div>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../index.html" title="內容目录"
             >toc</a></li>
        <li class="right" >
          <a href="../../executable/elf/index.html" title="ELF文件"
             >下一页</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="house_of_force.html" title="House Of Force"
             >上一页</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">CTF Wiki </a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >堆利用</a> &#187;</li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2017, CTF Wiki.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7 创建。
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>